# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'float', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'float'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota

CREATE TABLE TEST_QUOTA (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota

{
  "table": "test_quota",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000029A79E3FA90>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000029A79E4E210>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000029A79E3D250>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000029A79EBB1D0>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota

[
  "EFFECTIVE_START_TIME",
  "REMARKS",
  "CREATED_BY",
  "MINSLAB",
  "EFFECTIVE_END_TIME",
  "MAX_CAPACITY",
  "UNIT_COST_PER_MBPS_MONTHLY",
  "MIN_CAPACITY",
  "IS_CURRENT",
  "LOCKIN_MONTHS",
  "CONTRACT",
  "BUCKET",
  "LINK_TYPE"
]
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_upsert (SUCCESS)
- outputs:
  {'total': 33, 'success': 33, 'failed': 0, 'chunks': [{'total': 33, 'success': 33, 'failed': 0, 'method': 'bulk'}]}
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000029A79DB5A50>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000029A79EA9310>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000029A79EC2CD0>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boo...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_upsert (SUCCESS)
- outputs:
  {'total': 33, 'success': 33, 'failed': 0, 'chunks': [{'total': 33, 'success': 33, 'failed': 0, 'method': 'bulk'}]}
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(3, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(3, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    3034  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    3035 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    3036 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 1
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE  ... IS_CURRENT CREATED_BY
0     3034   SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1     3035  SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2     3036  SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN

[3 rows x 16 columns], {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'CONTRACT': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'LINK_TYPE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'BUCKET': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'MIN_CAPACITY': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'MAX_CAPACITY': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'UNIT_COST_PER_MBPS_MONTHLY': {'input_dtype': 'float64', 'output_dtype': 'float64'}, 'MINSLAB': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'LOCKIN_MONTHS': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'REMARKS': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'EFFECTIVE_START_TIME': {'input_dtype': 'object', 'output_dtype': 'datetime64[ns]'}, 'EFFECTIVE_END_TIME': {'input_dtype': 'object', 'output_dtype': 'datetime64[ns]'}, 'IS_CURRENT': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'CREATED_BY': {'input_dtype': 'float64', 'output_dtype': 'float64'}})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(3, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  chunk_size: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000029A79EB7C90>
  df: DataFrame(shape=(3, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000029A79ED1C50>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boo...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(3, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  3
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(1, 1), columns=['COST_CODE'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(1, 1)

                        COST_CODE
SCL*Robi-LP-001855-1*BH*2_UPDATED
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 1
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (                           COST_CODE
0  SCL*Robi-LP-001855-1*BH*2_UPDATED, {'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# crud_v2 - auto_update (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  table: test_quota
  data: DataFrame(shape=(1, 1), columns=['COST_CODE'])
  where: [('COST_ID', '=', 1001)]
  expression: None
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000029A79E903D0>
  df: DataFrame(shape=(1, 1), columns=['COST_CODE'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000029A79EC8090>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boo...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(1, 1), columns=['cost_code'])
------------------------------------------
# crud_v2 - auto_update (FAILURE)
- error: NotSupportedError: (oracledb.exceptions.NotSupportedError) DPY-3002: Python value of type "int64" is not supported
[SQL: UPDATE test_quota SET cost_code = :cost_code WHERE (COST_ID = :p0)]
[parameters: {'cost_code': 'SCL*Robi-LP-001855-1*BH*2_UPDATED', 'p0': 1001}]
(Background on this error at: https://sqlalche.me/e/20/tw8g)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate           2024-09-12         1970-01-01           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN           2024-09-12         1970-01-01           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN           2024-09-12         1970-01-01           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN           2024-09-12         1970-01-01           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN           2024-09-12         1970-01-01           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "datetime64[ns]",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "datetime64[ns]",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_CONTRACT

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_LINK_TYPE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_BUCKET

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MIN_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MAX_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_UNIT_COST_PER_MBPS_MONTHLY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MINSLAB

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_LOCKIN_MONTHS

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_REMARKS

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_START_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_END_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_IS_CURRENT

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_CREATED_BY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_CONTRACT

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_LINK_TYPE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_BUCKET

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MIN_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MAX_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_UNIT_COST_PER_MBPS_MONTHLY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MINSLAB

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_LOCKIN_MONTHS

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_REMARKS

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_START_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_END_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_IS_CURRENT

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_CREATED_BY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_CONTRACT

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_LINK_TYPE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_BUCKET

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MIN_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MAX_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_UNIT_COST_PER_MBPS_MONTHLY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MINSLAB

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_LOCKIN_MONTHS

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_REMARKS

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_START_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_END_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_IS_CURRENT

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_CREATED_BY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# STRING - ddl_oracle_test_quota

CREATE TABLE TEST_QUOTA (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONTRACT VARCHAR2(255) NOT NULL,
    LINK_TYPE VARCHAR2(255) NOT NULL,
    BUCKET NUMBER NOT NULL,
    MIN_CAPACITY NUMBER NOT NULL,
    MAX_CAPACITY NUMBER NOT NULL,
    UNIT_COST_PER_MBPS_MONTHLY BINARY_DOUBLE NOT NULL,
    MINSLAB NUMBER NOT NULL,
    LOCKIN_MONTHS NUMBER NOT NULL,
    REMARKS VARCHAR2(255) NULL,
    EFFECTIVE_START_TIME TIMESTAMP NOT NULL,
    EFFECTIVE_END_TIME TIMESTAMP NOT NULL,
    IS_CURRENT NUMBER NOT NULL,
    CREATED_BY BINARY_DOUBLE NULL,
    CONSTRAINT TEST_QUOTA_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota

{
  "table": "test_quota",
  "server": "oracle",
  "columns": 16,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000029A79EF2090>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000029A79ED38D0>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  33
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'float', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'float'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota

CREATE TABLE TEST_QUOTA (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota

{
  "table": "test_quota",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001C56F1A3B90>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001C56F1A6610>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota

CREATE TABLE TEST_QUOTA (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota

{
  "table": "test_quota",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000201D3DA3E50>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000201D3DA6D50>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000201D3D11E50>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000201D3E09110>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota

[
  "UNIT_COST_PER_MBPS_MONTHLY",
  "EFFECTIVE_END_TIME",
  "REMARKS",
  "MAX_CAPACITY",
  "BUCKET",
  "EFFECTIVE_START_TIME",
  "CREATED_BY",
  "MIN_CAPACITY",
  "LOCKIN_MONTHS",
  "MINSLAB",
  "CONTRACT",
  "IS_CURRENT",
  "LINK_TYPE"
]
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_upsert (SUCCESS)
- outputs:
  {'total': 33, 'success': 33, 'failed': 0, 'chunks': [{'total': 33, 'success': 33, 'failed': 0, 'method': 'bulk'}]}
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000201D3DCE990>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000201D3DF6590>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000201D3E2ED10>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boo...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_upsert (SUCCESS)
- outputs:
  {'total': 33, 'success': 33, 'failed': 0, 'chunks': [{'total': 33, 'success': 33, 'failed': 0, 'method': 'bulk'}]}
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(3, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(3, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    3034  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    3035 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    3036 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 1
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE  ... IS_CURRENT CREATED_BY
0     3034   SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1     3035  SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2     3036  SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN

[3 rows x 16 columns], {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'CONTRACT': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'LINK_TYPE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'BUCKET': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'MIN_CAPACITY': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'MAX_CAPACITY': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'UNIT_COST_PER_MBPS_MONTHLY': {'input_dtype': 'float64', 'output_dtype': 'float64'}, 'MINSLAB': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'LOCKIN_MONTHS': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'REMARKS': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'EFFECTIVE_START_TIME': {'input_dtype': 'object', 'output_dtype': 'datetime64[ns]'}, 'EFFECTIVE_END_TIME': {'input_dtype': 'object', 'output_dtype': 'datetime64[ns]'}, 'IS_CURRENT': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'CREATED_BY': {'input_dtype': 'float64', 'output_dtype': 'float64'}})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(3, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  chunk_size: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000201D3E08B50>
  df: DataFrame(shape=(3, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000201D3E17210>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boo...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(3, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  3
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(1, 1), columns=['COST_CODE'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(1, 1)

                        COST_CODE
SCL*Robi-LP-001855-1*BH*2_UPDATED
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 1
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (                           COST_CODE
0  SCL*Robi-LP-001855-1*BH*2_UPDATED, {'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# crud_v2 - auto_update (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  table: test_quota
  data: DataFrame(shape=(1, 1), columns=['COST_CODE'])
  where: [('COST_ID', '=', 1001)]
  expression: None
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000201D3E1CB10>
  df: DataFrame(shape=(1, 1), columns=['COST_CODE'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000201D3DA5650>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boo...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(1, 1), columns=['cost_code'])
------------------------------------------
# crud_v2 - auto_update (FAILURE)
- error: NotSupportedError: (oracledb.exceptions.NotSupportedError) DPY-3002: Python value of type "int64" is not supported
[SQL: UPDATE test_quota SET cost_code = :cost_code WHERE (COST_ID = :p0)]
[parameters: {'cost_code': 'SCL*Robi-LP-001855-1*BH*2_UPDATED', 'p0': 1001}]
(Background on this error at: https://sqlalche.me/e/20/tw8g)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate           2024-09-12         1970-01-01           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN           2024-09-12         1970-01-01           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN           2024-09-12         1970-01-01           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN           2024-09-12         1970-01-01           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN           2024-09-12         1970-01-01           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "datetime64[ns]",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "datetime64[ns]",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_CONTRACT

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_LINK_TYPE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_BUCKET

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MIN_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MAX_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_UNIT_COST_PER_MBPS_MONTHLY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MINSLAB

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_LOCKIN_MONTHS

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_REMARKS

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_START_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_END_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_IS_CURRENT

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_CREATED_BY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_CONTRACT

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_LINK_TYPE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_BUCKET

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MIN_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MAX_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_UNIT_COST_PER_MBPS_MONTHLY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MINSLAB

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_LOCKIN_MONTHS

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_REMARKS

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_START_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_END_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_IS_CURRENT

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_CREATED_BY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_CONTRACT

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_LINK_TYPE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_BUCKET

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MIN_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MAX_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_UNIT_COST_PER_MBPS_MONTHLY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MINSLAB

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_LOCKIN_MONTHS

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_REMARKS

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_START_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_END_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_IS_CURRENT

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_CREATED_BY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# STRING - ddl_oracle_test_quota

CREATE TABLE TEST_QUOTA (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONTRACT VARCHAR2(255) NOT NULL,
    LINK_TYPE VARCHAR2(255) NOT NULL,
    BUCKET NUMBER NOT NULL,
    MIN_CAPACITY NUMBER NOT NULL,
    MAX_CAPACITY NUMBER NOT NULL,
    UNIT_COST_PER_MBPS_MONTHLY BINARY_DOUBLE NOT NULL,
    MINSLAB NUMBER NOT NULL,
    LOCKIN_MONTHS NUMBER NOT NULL,
    REMARKS VARCHAR2(255) NULL,
    EFFECTIVE_START_TIME TIMESTAMP NOT NULL,
    EFFECTIVE_END_TIME TIMESTAMP NOT NULL,
    IS_CURRENT NUMBER NOT NULL,
    CREATED_BY BINARY_DOUBLE NULL,
    CONSTRAINT TEST_QUOTA_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota

{
  "table": "test_quota",
  "server": "oracle",
  "columns": 16,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000201D3E1F950>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000201D3FAB0D0>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  33
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'float', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'float'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota

CREATE TABLE TEST_QUOTA (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota

{
  "table": "test_quota",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000214AFEE9B10>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000214AFF25090>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000214AFF4E350>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000214AFF97F10>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota

[
  "CONTRACT",
  "EFFECTIVE_START_TIME",
  "BUCKET",
  "UNIT_COST_PER_MBPS_MONTHLY",
  "MINSLAB",
  "EFFECTIVE_END_TIME",
  "MIN_CAPACITY",
  "IS_CURRENT",
  "REMARKS",
  "LOCKIN_MONTHS",
  "LINK_TYPE",
  "MAX_CAPACITY",
  "CREATED_BY"
]
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_upsert (SUCCESS)
- outputs:
  {'total': 33, 'success': 33, 'failed': 0, 'chunks': [{'total': 33, 'success': 33, 'failed': 0, 'method': 'bulk'}]}
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000214AFEE9D50>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000214AFF8BA10>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000214AFF77310>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boo...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_upsert (SUCCESS)
- outputs:
  {'total': 33, 'success': 33, 'failed': 0, 'chunks': [{'total': 33, 'success': 33, 'failed': 0, 'method': 'bulk'}]}
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(3, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(3, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    3034  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    3035 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    3036 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 1
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE  ... IS_CURRENT CREATED_BY
0     3034   SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1     3035  SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2     3036  SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN

[3 rows x 16 columns], {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'CONTRACT': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'LINK_TYPE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'BUCKET': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'MIN_CAPACITY': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'MAX_CAPACITY': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'UNIT_COST_PER_MBPS_MONTHLY': {'input_dtype': 'float64', 'output_dtype': 'float64'}, 'MINSLAB': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'LOCKIN_MONTHS': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'REMARKS': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'EFFECTIVE_START_TIME': {'input_dtype': 'object', 'output_dtype': 'datetime64[ns]'}, 'EFFECTIVE_END_TIME': {'input_dtype': 'object', 'output_dtype': 'datetime64[ns]'}, 'IS_CURRENT': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'CREATED_BY': {'input_dtype': 'float64', 'output_dtype': 'float64'}})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(3, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  chunk_size: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000214AFF74190>
  df: DataFrame(shape=(3, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000214AFF94F90>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boo...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(3, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  3
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(1, 1), columns=['COST_CODE'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(1, 1)

                        COST_CODE
SCL*Robi-LP-001855-1*BH*2_UPDATED
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 1
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (                           COST_CODE
0  SCL*Robi-LP-001855-1*BH*2_UPDATED, {'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# crud_v2 - auto_update (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  table: test_quota
  data: DataFrame(shape=(1, 1), columns=['COST_CODE'])
  where: [('COST_ID', '=', 1001)]
  expression: None
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000214AFF96810>
  df: DataFrame(shape=(1, 1), columns=['COST_CODE'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000214AFF97C90>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boo...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(1, 1), columns=['cost_code'])
------------------------------------------
# crud_v2 - auto_update (SUCCESS)
- outputs:
  1
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate           2024-09-12         1970-01-01           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN           2024-09-12         1970-01-01           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN           2024-09-12         1970-01-01           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN           2024-09-12         1970-01-01           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN           2024-09-12         1970-01-01           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "datetime64[ns]",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "datetime64[ns]",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_CONTRACT

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_LINK_TYPE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_BUCKET

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MIN_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MAX_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_UNIT_COST_PER_MBPS_MONTHLY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MINSLAB

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_LOCKIN_MONTHS

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_REMARKS

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_START_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_END_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_IS_CURRENT

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_CREATED_BY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_CONTRACT

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_LINK_TYPE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_BUCKET

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MIN_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MAX_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_UNIT_COST_PER_MBPS_MONTHLY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MINSLAB

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_LOCKIN_MONTHS

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_REMARKS

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_START_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_END_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_IS_CURRENT

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_CREATED_BY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_CONTRACT

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_LINK_TYPE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_BUCKET

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MIN_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MAX_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_UNIT_COST_PER_MBPS_MONTHLY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MINSLAB

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_LOCKIN_MONTHS

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_REMARKS

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_START_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_END_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_IS_CURRENT

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_CREATED_BY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# STRING - ddl_oracle_test_quota

CREATE TABLE TEST_QUOTA (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONTRACT VARCHAR2(255) NOT NULL,
    LINK_TYPE VARCHAR2(255) NOT NULL,
    BUCKET NUMBER NOT NULL,
    MIN_CAPACITY NUMBER NOT NULL,
    MAX_CAPACITY NUMBER NOT NULL,
    UNIT_COST_PER_MBPS_MONTHLY BINARY_DOUBLE NOT NULL,
    MINSLAB NUMBER NOT NULL,
    LOCKIN_MONTHS NUMBER NOT NULL,
    REMARKS VARCHAR2(255) NULL,
    EFFECTIVE_START_TIME TIMESTAMP NOT NULL,
    EFFECTIVE_END_TIME TIMESTAMP NOT NULL,
    IS_CURRENT NUMBER NOT NULL,
    CREATED_BY BINARY_DOUBLE NULL,
    CONSTRAINT TEST_QUOTA_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota

{
  "table": "test_quota",
  "server": "oracle",
  "columns": 16,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000214B0108490>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000214B00F9CD0>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  33
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'float', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'float'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota

CREATE TABLE TEST_QUOTA (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota

{
  "table": "test_quota",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001D94D08E890>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001D94D095450>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001D94D0E3C50>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001D94D107FD0>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota

[
  "CONTRACT",
  "LINK_TYPE",
  "CREATED_BY",
  "MAX_CAPACITY",
  "MINSLAB",
  "UNIT_COST_PER_MBPS_MONTHLY",
  "BUCKET",
  "EFFECTIVE_END_TIME",
  "REMARKS",
  "EFFECTIVE_START_TIME",
  "MIN_CAPACITY",
  "IS_CURRENT",
  "LOCKIN_MONTHS"
]
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_upsert (SUCCESS)
- outputs:
  {'total': 33, 'success': 33, 'failed': 0, 'chunks': [{'total': 33, 'success': 33, 'failed': 0, 'method': 'bulk'}]}
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001D94CC10150>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001D94D0F8890>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001D94D118E50>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boo...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_upsert (SUCCESS)
- outputs:
  {'total': 33, 'success': 33, 'failed': 0, 'chunks': [{'total': 33, 'success': 33, 'failed': 0, 'method': 'bulk'}]}
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(3, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(3, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    3034  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    3035 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    3036 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 3
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 1
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE  ... IS_CURRENT CREATED_BY
0     3034   SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1     3035  SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2     3036  SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN

[3 rows x 16 columns], {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'CONTRACT': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'LINK_TYPE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'BUCKET': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'MIN_CAPACITY': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'MAX_CAPACITY': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'UNIT_COST_PER_MBPS_MONTHLY': {'input_dtype': 'float64', 'output_dtype': 'float64'}, 'MINSLAB': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'LOCKIN_MONTHS': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'REMARKS': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'EFFECTIVE_START_TIME': {'input_dtype': 'object', 'output_dtype': 'datetime64[ns]'}, 'EFFECTIVE_END_TIME': {'input_dtype': 'object', 'output_dtype': 'datetime64[ns]'}, 'IS_CURRENT': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'CREATED_BY': {'input_dtype': 'float64', 'output_dtype': 'float64'}})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(3, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  chunk_size: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001D94D11A6D0>
  df: DataFrame(shape=(3, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001D94D11DF90>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boo...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(3, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  3
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(1, 1), columns=['COST_CODE'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(1, 1)

                        COST_CODE
SCL*Robi-LP-001855-1*BH*2_UPDATED
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 1
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (                           COST_CODE
0  SCL*Robi-LP-001855-1*BH*2_UPDATED, {'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# crud_v2 - auto_update (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  table: test_quota
  data: DataFrame(shape=(1, 1), columns=['COST_CODE'])
  where: [('COST_ID', '=', 1001)]
  expression: None
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001D94D118B90>
  df: DataFrame(shape=(1, 1), columns=['COST_CODE'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001D94D08D9D0>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boo...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(1, 1), columns=['cost_code'])
------------------------------------------
# crud_v2 - auto_update (SUCCESS)
- outputs:
  1
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate           2024-09-12         1970-01-01           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN           2024-09-12         1970-01-01           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN           2024-09-12         1970-01-01           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN           2024-09-12         1970-01-01           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN           2024-09-12         1970-01-01           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "datetime64[ns]",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "datetime64[ns]",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_CONTRACT

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_LINK_TYPE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_BUCKET

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MIN_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MAX_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_UNIT_COST_PER_MBPS_MONTHLY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MINSLAB

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_LOCKIN_MONTHS

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_REMARKS

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_START_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_END_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_IS_CURRENT

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_CREATED_BY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_CONTRACT

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_LINK_TYPE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_BUCKET

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MIN_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MAX_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_UNIT_COST_PER_MBPS_MONTHLY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MINSLAB

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_LOCKIN_MONTHS

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_REMARKS

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_START_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_END_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_IS_CURRENT

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_CREATED_BY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_CONTRACT

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_LINK_TYPE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_BUCKET

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MIN_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MAX_CAPACITY

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_UNIT_COST_PER_MBPS_MONTHLY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_MINSLAB

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_LOCKIN_MONTHS

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_REMARKS

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_START_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_EFFECTIVE_END_TIME

{
  "pandas_dtype": "datetime64[ns]",
  "sql_type": "TIMESTAMP",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_IS_CURRENT

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_CREATED_BY

{
  "pandas_dtype": "float64",
  "sql_type": "BINARY_DOUBLE",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# STRING - ddl_oracle_test_quota

CREATE TABLE TEST_QUOTA (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONTRACT VARCHAR2(255) NOT NULL,
    LINK_TYPE VARCHAR2(255) NOT NULL,
    BUCKET NUMBER NOT NULL,
    MIN_CAPACITY NUMBER NOT NULL,
    MAX_CAPACITY NUMBER NOT NULL,
    UNIT_COST_PER_MBPS_MONTHLY BINARY_DOUBLE NOT NULL,
    MINSLAB NUMBER NOT NULL,
    LOCKIN_MONTHS NUMBER NOT NULL,
    REMARKS VARCHAR2(255) NULL,
    EFFECTIVE_START_TIME TIMESTAMP NOT NULL,
    EFFECTIVE_END_TIME TIMESTAMP NOT NULL,
    IS_CURRENT NUMBER NOT NULL,
    CREATED_BY BINARY_DOUBLE NULL,
    CONSTRAINT TEST_QUOTA_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota

{
  "table": "test_quota",
  "server": "oracle",
  "columns": 16,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001D94D12EAD0>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001D94D16C150>
  schema: None
  table_name: test_quota
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_...
------------------------------------------
# JSON - semantic_routing_test_quota

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  33
------------------------------------------
