# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota_evolve

CREATE TABLE TEST_QUOTA_EVOLVE (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota_evolve

{
  "table": "test_quota_evolve",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA_EVOLVE (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota_evolve', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001AB1EAE2E90>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001AB1EB08390>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001AB1EAFAE90>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001AB1EB86710>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota_evolve

[
  "MINSLAB",
  "CREATED_BY",
  "LINK_TYPE",
  "CONTRACT",
  "UNIT_COST_PER_MBPS_MONTHLY",
  "IS_CURRENT",
  "LOCKIN_MONTHS",
  "BUCKET",
  "MAX_CAPACITY",
  "EFFECTIVE_START_TIME",
  "EFFECTIVE_END_TIME",
  "MIN_CAPACITY",
  "REMARKS"
]
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_upsert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['cost_code', 'cost_id', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=1, row_keys=['cost_code', 'cost_id', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=2, row_keys=['cost_code', 'cost_id', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=3, row_keys=['cost_code', 'cost_id', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=4, row_keys=['cost_code', 'cost_id', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001AB1EAE2710>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001AB1EB790D0>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001AB1EB8E150>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False,...
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_upsert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=1, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=2, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=3, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=4, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota_evolve

CREATE TABLE TEST_QUOTA_EVOLVE (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota_evolve

{
  "table": "test_quota_evolve",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA_EVOLVE (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota_evolve', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001EDD60A5650>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001EDD6078B90>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001EDD43A8C50>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001EDD610CB90>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota_evolve

[
  "BUCKET",
  "CONTRACT",
  "LOCKIN_MONTHS",
  "MAX_CAPACITY",
  "IS_CURRENT",
  "EFFECTIVE_END_TIME",
  "MINSLAB",
  "MIN_CAPACITY",
  "UNIT_COST_PER_MBPS_MONTHLY",
  "LINK_TYPE",
  "CREATED_BY",
  "EFFECTIVE_START_TIME",
  "REMARKS"
]
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_upsert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['cost_code', 'cost_id', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=1, row_keys=['cost_code', 'cost_id', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=2, row_keys=['cost_code', 'cost_id', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=3, row_keys=['cost_code', 'cost_id', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=4, row_keys=['cost_code', 'cost_id', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001EDD60E0F10>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001EDD6108810>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001EDD60A5110>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False,...
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_upsert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=1, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=2, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=3, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
row_index=4, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=AttributeError: module 'sqlalchemy.dialects.oracle' has no attribute 'dml'
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota_evolve

CREATE TABLE TEST_QUOTA_EVOLVE (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota_evolve

{
  "table": "test_quota_evolve",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA_EVOLVE (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota_evolve', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000020F6C11F690>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000020F6A040610>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000020F6D601A50>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000020F6D556D90>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota_evolve

[
  "CREATED_BY",
  "MIN_CAPACITY",
  "MAX_CAPACITY",
  "REMARKS",
  "EFFECTIVE_END_TIME",
  "MINSLAB",
  "UNIT_COST_PER_MBPS_MONTHLY",
  "CONTRACT",
  "LINK_TYPE",
  "BUCKET",
  "EFFECTIVE_START_TIME",
  "LOCKIN_MONTHS",
  "IS_CURRENT"
]
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_upsert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor) VALUES (src.cost_id, src.cost_code, src.vendor)]
[parameters: {'cost_id': 1001, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['cost_code', 'cost_id', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor) VALUES (src.cost_id, src.cost_code, src.vendor)]
[parameters: {'cost_id': 1001, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=1, row_keys=['cost_code', 'cost_id', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor) VALUES (src.cost_id, src.cost_code, src.vendor)]
[parameters: {'cost_id': 1002, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=2, row_keys=['cost_code', 'cost_id', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor) VALUES (src.cost_id, src.cost_code, src.vendor)]
[parameters: {'cost_id': 1003, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=3, row_keys=['cost_code', 'cost_id', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor) VALUES (src.cost_id, src.cost_code, src.vendor)]
[parameters: {'cost_id': 1004, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=4, row_keys=['cost_code', 'cost_id', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor) VALUES (src.cost_id, src.cost_code, src.vendor)]
[parameters: {'cost_id': 1005, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000020F6D5B3310>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000020F6D5C1710>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000020F6D5D8E50>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False,...
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_upsert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor, :contract AS contract, :link_type AS link_type, :bucket AS bucket, :min_capacity AS min_capacity, :max_capacity AS max_capacity, :unit_cost_per_mbps_monthly AS unit_cost_per_mbps_monthly, :minslab AS minslab, :lockin_months AS lockin_months, :remarks AS remarks, :effective_start_time AS effective_start_time, :effective_end_time AS effective_end_time, :is_current AS is_current, :created_by AS created_by FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor, tgt.contract = src.contract, tgt.link_type = src.link_type, tgt.bucket = src.bucket, tgt.min_capacity = src.min_capacity, tgt.max_capacity = src.max_capacity, tgt.unit_cost_per_mbps_monthly = src.unit_cost_per_mbps_monthly, tgt.minslab = src.minslab, tgt.lockin_months = src.lockin_months, tgt.remarks = src.remarks, tgt.effective_start_time = src.effective_start_time, tgt.effective_end_time = src.effective_end_time, tgt.is_current = src.is_current, tgt.created_by = src.created_by WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (src.cost_id, src.cost_code, src.vendor, src.contract, src.link_type, src.bucket, src.min_capacity, src.max_capacity, src.unit_cost_per_mbps_monthly, src.minslab, src.lockin_months, src.remarks, src.effective_start_time, src.effective_end_time, src.is_current, src.created_by)]
[parameters: {'cost_id': 1001, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 100, 'unit_cost_per_mbps_monthly': 30.0, 'minslab': 70000, 'lockin_months': 1, 'remarks': 'No per mbps rate', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor, :contract AS contract, :link_type AS link_type, :bucket AS bucket, :min_capacity AS min_capacity, :max_capacity AS max_capacity, :unit_cost_per_mbps_monthly AS unit_cost_per_mbps_monthly, :minslab AS minslab, :lockin_months AS lockin_months, :remarks AS remarks, :effective_start_time AS effective_start_time, :effective_end_time AS effective_end_time, :is_current AS is_current, :created_by AS created_by FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor, tgt.contract = src.contract, tgt.link_type = src.link_type, tgt.bucket = src.bucket, tgt.min_capacity = src.min_capacity, tgt.max_capacity = src.max_capacity, tgt.unit_cost_per_mbps_monthly = src.unit_cost_per_mbps_monthly, tgt.minslab = src.minslab, tgt.lockin_months = src.lockin_months, tgt.remarks = src.remarks, tgt.effective_start_time = src.effective_start_time, tgt.effective_end_time = src.effective_end_time, tgt.is_current = src.is_current, tgt.created_by = src.created_by WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (src.cost_id, src.cost_code, src.vendor, src.contract, src.link_type, src.bucket, src.min_capacity, src.max_capacity, src.unit_cost_per_mbps_monthly, src.minslab, src.lockin_months, src.remarks, src.effective_start_time, src.effective_end_time, src.is_current, src.created_by)]
[parameters: {'cost_id': 1001, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 100, 'unit_cost_per_mbps_monthly': 30.0, 'minslab': 70000, 'lockin_months': 1, 'remarks': 'No per mbps rate', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=1, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor, :contract AS contract, :link_type AS link_type, :bucket AS bucket, :min_capacity AS min_capacity, :max_capacity AS max_capacity, :unit_cost_per_mbps_monthly AS unit_cost_per_mbps_monthly, :minslab AS minslab, :lockin_months AS lockin_months, :remarks AS remarks, :effective_start_time AS effective_start_time, :effective_end_time AS effective_end_time, :is_current AS is_current, :created_by AS created_by FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor, tgt.contract = src.contract, tgt.link_type = src.link_type, tgt.bucket = src.bucket, tgt.min_capacity = src.min_capacity, tgt.max_capacity = src.max_capacity, tgt.unit_cost_per_mbps_monthly = src.unit_cost_per_mbps_monthly, tgt.minslab = src.minslab, tgt.lockin_months = src.lockin_months, tgt.remarks = src.remarks, tgt.effective_start_time = src.effective_start_time, tgt.effective_end_time = src.effective_end_time, tgt.is_current = src.is_current, tgt.created_by = src.created_by WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (src.cost_id, src.cost_code, src.vendor, src.contract, src.link_type, src.bucket, src.min_capacity, src.max_capacity, src.unit_cost_per_mbps_monthly, src.minslab, src.lockin_months, src.remarks, src.effective_start_time, src.effective_end_time, src.is_current, src.created_by)]
[parameters: {'cost_id': 1002, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-6', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 1, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=2, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor, :contract AS contract, :link_type AS link_type, :bucket AS bucket, :min_capacity AS min_capacity, :max_capacity AS max_capacity, :unit_cost_per_mbps_monthly AS unit_cost_per_mbps_monthly, :minslab AS minslab, :lockin_months AS lockin_months, :remarks AS remarks, :effective_start_time AS effective_start_time, :effective_end_time AS effective_end_time, :is_current AS is_current, :created_by AS created_by FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor, tgt.contract = src.contract, tgt.link_type = src.link_type, tgt.bucket = src.bucket, tgt.min_capacity = src.min_capacity, tgt.max_capacity = src.max_capacity, tgt.unit_cost_per_mbps_monthly = src.unit_cost_per_mbps_monthly, tgt.minslab = src.minslab, tgt.lockin_months = src.lockin_months, tgt.remarks = src.remarks, tgt.effective_start_time = src.effective_start_time, tgt.effective_end_time = src.effective_end_time, tgt.is_current = src.is_current, tgt.created_by = src.created_by WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (src.cost_id, src.cost_code, src.vendor, src.contract, src.link_type, src.bucket, src.min_capacity, src.max_capacity, src.unit_cost_per_mbps_monthly, src.minslab, src.lockin_months, src.remarks, src.effective_start_time, src.effective_end_time, src.is_current, src.created_by)]
[parameters: {'cost_id': 1003, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 12, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=3, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor, :contract AS contract, :link_type AS link_type, :bucket AS bucket, :min_capacity AS min_capacity, :max_capacity AS max_capacity, :unit_cost_per_mbps_monthly AS unit_cost_per_mbps_monthly, :minslab AS minslab, :lockin_months AS lockin_months, :remarks AS remarks, :effective_start_time AS effective_start_time, :effective_end_time AS effective_end_time, :is_current AS is_current, :created_by AS created_by FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor, tgt.contract = src.contract, tgt.link_type = src.link_type, tgt.bucket = src.bucket, tgt.min_capacity = src.min_capacity, tgt.max_capacity = src.max_capacity, tgt.unit_cost_per_mbps_monthly = src.unit_cost_per_mbps_monthly, tgt.minslab = src.minslab, tgt.lockin_months = src.lockin_months, tgt.remarks = src.remarks, tgt.effective_start_time = src.effective_start_time, tgt.effective_end_time = src.effective_end_time, tgt.is_current = src.is_current, tgt.created_by = src.created_by WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (src.cost_id, src.cost_code, src.vendor, src.contract, src.link_type, src.bucket, src.min_capacity, src.max_capacity, src.unit_cost_per_mbps_monthly, src.minslab, src.lockin_months, src.remarks, src.effective_start_time, src.effective_end_time, src.is_current, src.created_by)]
[parameters: {'cost_id': 1004, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 2, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=4, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor, :contract AS contract, :link_type AS link_type, :bucket AS bucket, :min_capacity AS min_capacity, :max_capacity AS max_capacity, :unit_cost_per_mbps_monthly AS unit_cost_per_mbps_monthly, :minslab AS minslab, :lockin_months AS lockin_months, :remarks AS remarks, :effective_start_time AS effective_start_time, :effective_end_time AS effective_end_time, :is_current AS is_current, :created_by AS created_by FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor, tgt.contract = src.contract, tgt.link_type = src.link_type, tgt.bucket = src.bucket, tgt.min_capacity = src.min_capacity, tgt.max_capacity = src.max_capacity, tgt.unit_cost_per_mbps_monthly = src.unit_cost_per_mbps_monthly, tgt.minslab = src.minslab, tgt.lockin_months = src.lockin_months, tgt.remarks = src.remarks, tgt.effective_start_time = src.effective_start_time, tgt.effective_end_time = src.effective_end_time, tgt.is_current = src.is_current, tgt.created_by = src.created_by WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (src.cost_id, src.cost_code, src.vendor, src.contract, src.link_type, src.bucket, src.min_capacity, src.max_capacity, src.unit_cost_per_mbps_monthly, src.minslab, src.lockin_months, src.remarks, src.effective_start_time, src.effective_end_time, src.is_current, src.created_by)]
[parameters: {'cost_id': 1005, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-3', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota_evolve

CREATE TABLE TEST_QUOTA_EVOLVE (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota_evolve

{
  "table": "test_quota_evolve",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA_EVOLVE (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota_evolve', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000021791885410>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000217918C9B50>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000021791884C90>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000217918B54D0>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota_evolve

[
  "MIN_CAPACITY",
  "REMARKS",
  "LINK_TYPE",
  "MAX_CAPACITY",
  "CONTRACT",
  "CREATED_BY",
  "IS_CURRENT",
  "UNIT_COST_PER_MBPS_MONTHLY",
  "MINSLAB",
  "BUCKET",
  "EFFECTIVE_END_TIME",
  "EFFECTIVE_START_TIME",
  "LOCKIN_MONTHS"
]
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_upsert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor) VALUES (src.cost_id, src.cost_code, src.vendor)]
[parameters: {'cost_id': 1001, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['cost_code', 'cost_id', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor) VALUES (src.cost_id, src.cost_code, src.vendor)]
[parameters: {'cost_id': 1001, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=1, row_keys=['cost_code', 'cost_id', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor) VALUES (src.cost_id, src.cost_code, src.vendor)]
[parameters: {'cost_id': 1002, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=2, row_keys=['cost_code', 'cost_id', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor) VALUES (src.cost_id, src.cost_code, src.vendor)]
[parameters: {'cost_id': 1003, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=3, row_keys=['cost_code', 'cost_id', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor) VALUES (src.cost_id, src.cost_code, src.vendor)]
[parameters: {'cost_id': 1004, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=4, row_keys=['cost_code', 'cost_id', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor) VALUES (src.cost_id, src.cost_code, src.vendor)]
[parameters: {'cost_id': 1005, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000021791885150>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000021791916C90>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000002179192DB90>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False,...
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_upsert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor, :contract AS contract, :link_type AS link_type, :bucket AS bucket, :min_capacity AS min_capacity, :max_capacity AS max_capacity, :unit_cost_per_mbps_monthly AS unit_cost_per_mbps_monthly, :minslab AS minslab, :lockin_months AS lockin_months, :remarks AS remarks, :effective_start_time AS effective_start_time, :effective_end_time AS effective_end_time, :is_current AS is_current, :created_by AS created_by FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor, tgt.contract = src.contract, tgt.link_type = src.link_type, tgt.bucket = src.bucket, tgt.min_capacity = src.min_capacity, tgt.max_capacity = src.max_capacity, tgt.unit_cost_per_mbps_monthly = src.unit_cost_per_mbps_monthly, tgt.minslab = src.minslab, tgt.lockin_months = src.lockin_months, tgt.remarks = src.remarks, tgt.effective_start_time = src.effective_start_time, tgt.effective_end_time = src.effective_end_time, tgt.is_current = src.is_current, tgt.created_by = src.created_by WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (src.cost_id, src.cost_code, src.vendor, src.contract, src.link_type, src.bucket, src.min_capacity, src.max_capacity, src.unit_cost_per_mbps_monthly, src.minslab, src.lockin_months, src.remarks, src.effective_start_time, src.effective_end_time, src.is_current, src.created_by)]
[parameters: {'cost_id': 1001, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 100, 'unit_cost_per_mbps_monthly': 30.0, 'minslab': 70000, 'lockin_months': 1, 'remarks': 'No per mbps rate', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor, :contract AS contract, :link_type AS link_type, :bucket AS bucket, :min_capacity AS min_capacity, :max_capacity AS max_capacity, :unit_cost_per_mbps_monthly AS unit_cost_per_mbps_monthly, :minslab AS minslab, :lockin_months AS lockin_months, :remarks AS remarks, :effective_start_time AS effective_start_time, :effective_end_time AS effective_end_time, :is_current AS is_current, :created_by AS created_by FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor, tgt.contract = src.contract, tgt.link_type = src.link_type, tgt.bucket = src.bucket, tgt.min_capacity = src.min_capacity, tgt.max_capacity = src.max_capacity, tgt.unit_cost_per_mbps_monthly = src.unit_cost_per_mbps_monthly, tgt.minslab = src.minslab, tgt.lockin_months = src.lockin_months, tgt.remarks = src.remarks, tgt.effective_start_time = src.effective_start_time, tgt.effective_end_time = src.effective_end_time, tgt.is_current = src.is_current, tgt.created_by = src.created_by WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (src.cost_id, src.cost_code, src.vendor, src.contract, src.link_type, src.bucket, src.min_capacity, src.max_capacity, src.unit_cost_per_mbps_monthly, src.minslab, src.lockin_months, src.remarks, src.effective_start_time, src.effective_end_time, src.is_current, src.created_by)]
[parameters: {'cost_id': 1001, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 100, 'unit_cost_per_mbps_monthly': 30.0, 'minslab': 70000, 'lockin_months': 1, 'remarks': 'No per mbps rate', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=1, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor, :contract AS contract, :link_type AS link_type, :bucket AS bucket, :min_capacity AS min_capacity, :max_capacity AS max_capacity, :unit_cost_per_mbps_monthly AS unit_cost_per_mbps_monthly, :minslab AS minslab, :lockin_months AS lockin_months, :remarks AS remarks, :effective_start_time AS effective_start_time, :effective_end_time AS effective_end_time, :is_current AS is_current, :created_by AS created_by FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor, tgt.contract = src.contract, tgt.link_type = src.link_type, tgt.bucket = src.bucket, tgt.min_capacity = src.min_capacity, tgt.max_capacity = src.max_capacity, tgt.unit_cost_per_mbps_monthly = src.unit_cost_per_mbps_monthly, tgt.minslab = src.minslab, tgt.lockin_months = src.lockin_months, tgt.remarks = src.remarks, tgt.effective_start_time = src.effective_start_time, tgt.effective_end_time = src.effective_end_time, tgt.is_current = src.is_current, tgt.created_by = src.created_by WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (src.cost_id, src.cost_code, src.vendor, src.contract, src.link_type, src.bucket, src.min_capacity, src.max_capacity, src.unit_cost_per_mbps_monthly, src.minslab, src.lockin_months, src.remarks, src.effective_start_time, src.effective_end_time, src.is_current, src.created_by)]
[parameters: {'cost_id': 1002, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-6', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 1, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=2, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor, :contract AS contract, :link_type AS link_type, :bucket AS bucket, :min_capacity AS min_capacity, :max_capacity AS max_capacity, :unit_cost_per_mbps_monthly AS unit_cost_per_mbps_monthly, :minslab AS minslab, :lockin_months AS lockin_months, :remarks AS remarks, :effective_start_time AS effective_start_time, :effective_end_time AS effective_end_time, :is_current AS is_current, :created_by AS created_by FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor, tgt.contract = src.contract, tgt.link_type = src.link_type, tgt.bucket = src.bucket, tgt.min_capacity = src.min_capacity, tgt.max_capacity = src.max_capacity, tgt.unit_cost_per_mbps_monthly = src.unit_cost_per_mbps_monthly, tgt.minslab = src.minslab, tgt.lockin_months = src.lockin_months, tgt.remarks = src.remarks, tgt.effective_start_time = src.effective_start_time, tgt.effective_end_time = src.effective_end_time, tgt.is_current = src.is_current, tgt.created_by = src.created_by WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (src.cost_id, src.cost_code, src.vendor, src.contract, src.link_type, src.bucket, src.min_capacity, src.max_capacity, src.unit_cost_per_mbps_monthly, src.minslab, src.lockin_months, src.remarks, src.effective_start_time, src.effective_end_time, src.is_current, src.created_by)]
[parameters: {'cost_id': 1003, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 12, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=3, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor, :contract AS contract, :link_type AS link_type, :bucket AS bucket, :min_capacity AS min_capacity, :max_capacity AS max_capacity, :unit_cost_per_mbps_monthly AS unit_cost_per_mbps_monthly, :minslab AS minslab, :lockin_months AS lockin_months, :remarks AS remarks, :effective_start_time AS effective_start_time, :effective_end_time AS effective_end_time, :is_current AS is_current, :created_by AS created_by FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor, tgt.contract = src.contract, tgt.link_type = src.link_type, tgt.bucket = src.bucket, tgt.min_capacity = src.min_capacity, tgt.max_capacity = src.max_capacity, tgt.unit_cost_per_mbps_monthly = src.unit_cost_per_mbps_monthly, tgt.minslab = src.minslab, tgt.lockin_months = src.lockin_months, tgt.remarks = src.remarks, tgt.effective_start_time = src.effective_start_time, tgt.effective_end_time = src.effective_end_time, tgt.is_current = src.is_current, tgt.created_by = src.created_by WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (src.cost_id, src.cost_code, src.vendor, src.contract, src.link_type, src.bucket, src.min_capacity, src.max_capacity, src.unit_cost_per_mbps_monthly, src.minslab, src.lockin_months, src.remarks, src.effective_start_time, src.effective_end_time, src.is_current, src.created_by)]
[parameters: {'cost_id': 1004, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 2, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
row_index=4, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=DatabaseError: (oracledb.exceptions.DatabaseError) ORA-38104: Columns referenced in the ON Clause cannot be updated: "TGT"."COST_ID"
Help: https://docs.oracle.com/error-help/db/ora-38104/
[SQL: MERGE INTO test_quota_evolve tgt USING (SELECT :cost_id AS cost_id, :cost_code AS cost_code, :vendor AS vendor, :contract AS contract, :link_type AS link_type, :bucket AS bucket, :min_capacity AS min_capacity, :max_capacity AS max_capacity, :unit_cost_per_mbps_monthly AS unit_cost_per_mbps_monthly, :minslab AS minslab, :lockin_months AS lockin_months, :remarks AS remarks, :effective_start_time AS effective_start_time, :effective_end_time AS effective_end_time, :is_current AS is_current, :created_by AS created_by FROM DUAL) src ON (tgt.COST_ID = src.COST_ID) WHEN MATCHED THEN UPDATE SET tgt.cost_id = src.cost_id, tgt.cost_code = src.cost_code, tgt.vendor = src.vendor, tgt.contract = src.contract, tgt.link_type = src.link_type, tgt.bucket = src.bucket, tgt.min_capacity = src.min_capacity, tgt.max_capacity = src.max_capacity, tgt.unit_cost_per_mbps_monthly = src.unit_cost_per_mbps_monthly, tgt.minslab = src.minslab, tgt.lockin_months = src.lockin_months, tgt.remarks = src.remarks, tgt.effective_start_time = src.effective_start_time, tgt.effective_end_time = src.effective_end_time, tgt.is_current = src.is_current, tgt.created_by = src.created_by WHEN NOT MATCHED THEN INSERT (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (src.cost_id, src.cost_code, src.vendor, src.contract, src.link_type, src.bucket, src.min_capacity, src.max_capacity, src.unit_cost_per_mbps_monthly, src.minslab, src.lockin_months, src.remarks, src.effective_start_time, src.effective_end_time, src.is_current, src.created_by)]
[parameters: {'cost_id': 1005, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-3', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota_evolve

CREATE TABLE TEST_QUOTA_EVOLVE (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota_evolve

{
  "table": "test_quota_evolve",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA_EVOLVE (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota_evolve', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000019474475A10>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001947400A6D0>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000194744A5B50>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000019474422090>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota_evolve

[
  "LINK_TYPE",
  "IS_CURRENT",
  "CREATED_BY",
  "CONTRACT",
  "EFFECTIVE_START_TIME",
  "LOCKIN_MONTHS",
  "UNIT_COST_PER_MBPS_MONTHLY",
  "MIN_CAPACITY",
  "BUCKET",
  "MAX_CAPACITY",
  "MINSLAB",
  "REMARKS",
  "EFFECTIVE_END_TIME"
]
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_upsert (SUCCESS)
- outputs:
  {'total': 33, 'success': 33, 'failed': 0, 'chunks': [{'total': 33, 'success': 33, 'failed': 0, 'method': 'bulk'}]}
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001947400BB10>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001947453EBD0>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000019474549E90>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False,...
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_upsert (SUCCESS)
- outputs:
  {'total': 33, 'success': 33, 'failed': 0, 'chunks': [{'total': 33, 'success': 33, 'failed': 0, 'method': 'bulk'}]}
------------------------------------------
