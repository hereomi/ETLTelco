# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# data_profiler - profile_dataframe (START)
- inputs:
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])

# data_profiler - profile_dataframe (SUCCESS)
- outputs:
  DataFrame(shape=(3, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])
------------------------------------------
# data_profiler - get_pk (START)
- inputs:
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dfinfo: DataFrame(shape=(3, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])

# JSON - pk_detection

{
  "pk_name": "pk",
  "components": [
    "COST_ID"
  ],
  "is_unique": true,
  "non_null_rows": 0,
  "warnings": []
}
------------------------------------------
# data_profiler - get_pk (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR    pk
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL  1001
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL  1002
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL  1003
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL  1004
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL  1005, 'pk', {'components': ['COST_ID'], 'is_unique': True, 'non_null_pk_rows': 0})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota_evolve

CREATE TABLE TEST_QUOTA_EVOLVE (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota_evolve

{
  "table": "test_quota_evolve",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA_EVOLVE (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota_evolve', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000027714B4ED10>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000027714B57010>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# data_profiler - profile_dataframe (START)
- inputs:
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])

# JSON - high_null_columns

[
  {
    "Column": "REMARKS",
    "Data Type": "object",
    "Is Categorical": "False",
    "All Unique": "False",
    "Is Datetime": false,
    "Count of None": "25",
    "Data Length (Non-Null)": "8",
    "% of None": 75.76,
    "Total Unique Data Points": 5
  },
  {
    "Column": "CREATED_BY",
    "Data Type": "float64",
    "Is Categorical": "False",
    "All Unique": "False",
    "Is Datetime": false,
    "Count of None": "33",
    "Data Length (Non-Null)": "0",
    "% of None": 100.0,
    "Total Unique Data Points": 0
  }
]
------------------------------------------
# data_profiler - profile_dataframe (SUCCESS)
- outputs:
  DataFrame(shape=(16, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])
------------------------------------------
# data_profiler - get_pk (START)
- inputs:
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dfinfo: DataFrame(shape=(16, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])

# JSON - pk_detection

{
  "pk_name": "pk",
  "components": [
    "COST_ID"
  ],
  "is_unique": true,
  "non_null_rows": 0,
  "warnings": []
}
------------------------------------------
# data_profiler - get_pk (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... CREATED_BY    pk
0      1001     SCL*Robi-LP-001855-1*BH*2  ...        NaN  1001
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...        NaN  1002
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...        NaN  1003
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...        NaN  1004
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...        NaN  1005
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...        NaN  1006
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...        NaN  1007
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...        NaN  1008
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...        NaN  1009
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...        NaN  1010
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...        NaN  1011
11     1012     FHL*Robi-LP-001358-5*BH*1  ...        NaN  1012
12     1013     FHL*Robi-LP-001358-5*BH*2  ...        NaN  1013
13     1014     FHL*Robi-LP-001358-5*BH*3  ...        NaN  1014
14     1015     FHL*Robi-LP-001358-5*LM*1  ...        NaN  1015
15     1016     FHL*Robi-LP-001358-5*LM*2  ...        NaN  1016
16     1017     FHL*Robi-LP-001358-5*LM*3  ...        NaN  1017
17     1018     SCL*Robi-LP-001855-4*BH*1  ...        NaN  1018
18     1019     SCL*Robi-LP-001855-4*BH*2  ...        NaN  1019
19     1020     SCL*Robi-LP-001855-4*LM*1  ...        NaN  1020
20     1021     SCL*Robi-LP-001091-3*BH*1  ...        NaN  1021
21     1022     SCL*Robi-LP-001091-3*LM*1  ...        NaN  1022
22     1023     FHL*Robi-LP-001090-3*LM*1  ...        NaN  1023
23     1024     FHL*Robi-LP-001090-3*LM*2  ...        NaN  1024
24     1025     FHL*Robi-LP-001090-3*BH*3  ...        NaN  1025
25     1026     SCL*Robi-LP-001855-1*BH*1  ...        NaN  1026
26     1027     FHL*Robi-LP-001358-3*BH*1  ...        NaN  1027
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...        NaN  1028
28     1029   SCL*Robi-LP-001855-7-1*LM*2  ...        NaN  1029
29     1030   SCL*Robi-LP-001855-7-1*BH*1  ...        NaN  1030
30     1031  FH...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000027714B56310>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000027714B4DED0>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota_evolve

[
  "LINK_TYPE",
  "EFFECTIVE_START_TIME",
  "IS_CURRENT",
  "LOCKIN_MONTHS",
  "MINSLAB",
  "MIN_CAPACITY",
  "UNIT_COST_PER_MBPS_MONTHLY",
  "BUCKET",
  "CONTRACT",
  "REMARKS",
  "MAX_CAPACITY",
  "CREATED_BY",
  "EFFECTIVE_END_TIME"
]
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: [{'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL'}, {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL'}, {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1006.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*3', 'vendor': 'FHL'}, {'cost_id': 1007.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*2', 'vendor': 'FHL'}, {'cost_id': 1008.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*LM*2', 'vendor': 'FHL'}  ... displaying 10 of 33 total bound parameter sets ...  {'cost_id': 1032.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*1', 'vendor': 'SCL'}, {'cost_id': 1033.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*2', 'vendor': 'SCL'}]]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
Stats: 0/33 succeeded

⚠️ Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=1, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=2, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=3, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=4, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# data_profiler - profile_dataframe (START)
- inputs:
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])

# JSON - high_null_columns

[
  {
    "Column": "REMARKS",
    "Data Type": "object",
    "Is Categorical": "False",
    "All Unique": "False",
    "Is Datetime": false,
    "Count of None": "25",
    "Data Length (Non-Null)": "8",
    "% of None": 75.76,
    "Total Unique Data Points": 5
  },
  {
    "Column": "CREATED_BY",
    "Data Type": "float64",
    "Is Categorical": "False",
    "All Unique": "False",
    "Is Datetime": false,
    "Count of None": "33",
    "Data Length (Non-Null)": "0",
    "% of None": 100.0,
    "Total Unique Data Points": 0
  }
]
------------------------------------------
# data_profiler - profile_dataframe (SUCCESS)
- outputs:
  DataFrame(shape=(16, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])
------------------------------------------
# data_profiler - get_pk (START)
- inputs:
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dfinfo: DataFrame(shape=(16, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])

# JSON - pk_detection

{
  "pk_name": "pk",
  "components": [
    "COST_ID"
  ],
  "is_unique": true,
  "non_null_rows": 0,
  "warnings": []
}
------------------------------------------
# data_profiler - get_pk (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... CREATED_BY    pk
0      1001     SCL*Robi-LP-001855-1*BH*2  ...        NaN  1001
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...        NaN  1002
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...        NaN  1003
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...        NaN  1004
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...        NaN  1005
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...        NaN  1006
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...        NaN  1007
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...        NaN  1008
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...        NaN  1009
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...        NaN  1010
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...        NaN  1011
11     1012     FHL*Robi-LP-001358-5*BH*1  ...        NaN  1012
12     1013     FHL*Robi-LP-001358-5*BH*2  ...        NaN  1013
13     1014     FHL*Robi-LP-001358-5*BH*3  ...        NaN  1014
14     1015     FHL*Robi-LP-001358-5*LM*1  ...        NaN  1015
15     1016     FHL*Robi-LP-001358-5*LM*2  ...        NaN  1016
16     1017     FHL*Robi-LP-001358-5*LM*3  ...        NaN  1017
17     1018     SCL*Robi-LP-001855-4*BH*1  ...        NaN  1018
18     1019     SCL*Robi-LP-001855-4*BH*2  ...        NaN  1019
19     1020     SCL*Robi-LP-001855-4*LM*1  ...        NaN  1020
20     1021     SCL*Robi-LP-001091-3*BH*1  ...        NaN  1021
21     1022     SCL*Robi-LP-001091-3*LM*1  ...        NaN  1022
22     1023     FHL*Robi-LP-001090-3*LM*1  ...        NaN  1023
23     1024     FHL*Robi-LP-001090-3*LM*2  ...        NaN  1024
24     1025     FHL*Robi-LP-001090-3*BH*3  ...        NaN  1025
25     1026     SCL*Robi-LP-001855-1*BH*1  ...        NaN  1026
26     1027     FHL*Robi-LP-001358-3*BH*1  ...        NaN  1027
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...        NaN  1028
28     1029   SCL*Robi-LP-001855-7-1*LM*2  ...        NaN  1029
29     1030   SCL*Robi-LP-001855-7-1*BH*1  ...        NaN  1030
30     1031  FH...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000027714BD0150>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000027714BD0C50>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000027714C00090>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False,...
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_insert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: [{'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 100, 'unit_cost_per_mbps_monthly': 30.0, 'minslab': 70000, 'lockin_months': 1, 'remarks': 'No per mbps rate', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-6', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 1, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 12, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 2, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-3', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1006.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*3', 'vendor': 'FHL', 'contract': 'ROBI-TH-LP-230030', 'link_type': 'BH', 'bucket': 3, 'min_capacity': 1, 'max_capacity': 1000, 'unit_cost_per_mbps_monthly': 207.0, 'minslab': 0, 'lockin_months': 36, 'remarks': 'Regular Price', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1007.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*2', 'vendor': 'FHL', 'contract': 'ROBI-TH-LP-230030', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 2501, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 98.0, 'minslab': 0, 'lockin_months': 36, 'remarks': 'Regular Price', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1008.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*LM*2', 'vendor': 'FHL', 'contract': 'ROBI-TH-LP-230030', 'link_type': 'LM', 'bucket': 2, 'min_capacity': 101, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 88.0, 'minslab': 0, 'lockin_months': 36, 'remarks': 'Regular Price', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}  ... displaying 10 of 33 total bound parameter sets ...  {'cost_id': 1032.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'LM', 'bucket': 1, 'min_capacity': 1, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 86.0, 'minslab': 0, 'lockin_months': 1, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 13, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 2, 'created_by': None}, {'cost_id': 1033.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'LM', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 118.0, 'minslab': 0, 'lockin_months': 1, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 14, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 3, 'created_by': None}]]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
Stats: 0/33 succeeded

⚠️ Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 100, 'unit_cost_per_mbps_monthly': 30.0, 'minslab': 70000, 'lockin_months': 1, 'remarks': 'No per mbps rate', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=1, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-6', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 1, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=2, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 12, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=3, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 2, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=4, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-3', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# data_profiler - profile_dataframe (START)
- inputs:
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])

# data_profiler - profile_dataframe (SUCCESS)
- outputs:
  DataFrame(shape=(3, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])
------------------------------------------
# data_profiler - get_pk (START)
- inputs:
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dfinfo: DataFrame(shape=(3, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])

# JSON - pk_detection

{
  "pk_name": "pk",
  "components": [
    "COST_ID"
  ],
  "is_unique": true,
  "non_null_rows": 0,
  "warnings": []
}
------------------------------------------
# data_profiler - get_pk (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR    pk
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL  1001
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL  1002
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL  1003
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL  1004
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL  1005, 'pk', {'components': ['COST_ID'], 'is_unique': True, 'non_null_pk_rows': 0})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota_evolve

CREATE TABLE TEST_QUOTA_EVOLVE (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota_evolve

{
  "table": "test_quota_evolve",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA_EVOLVE (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota_evolve', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000189B5CF4410>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000189B5D455D0>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# data_profiler - profile_dataframe (START)
- inputs:
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])

# JSON - high_null_columns

[
  {
    "Column": "REMARKS",
    "Data Type": "object",
    "Is Categorical": "False",
    "All Unique": "False",
    "Is Datetime": false,
    "Count of None": "25",
    "Data Length (Non-Null)": "8",
    "% of None": 75.76,
    "Total Unique Data Points": 5
  },
  {
    "Column": "CREATED_BY",
    "Data Type": "float64",
    "Is Categorical": "False",
    "All Unique": "False",
    "Is Datetime": false,
    "Count of None": "33",
    "Data Length (Non-Null)": "0",
    "% of None": 100.0,
    "Total Unique Data Points": 0
  }
]
------------------------------------------
# data_profiler - profile_dataframe (SUCCESS)
- outputs:
  DataFrame(shape=(16, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])
------------------------------------------
# data_profiler - get_pk (START)
- inputs:
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dfinfo: DataFrame(shape=(16, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])

# JSON - pk_detection

{
  "pk_name": "pk",
  "components": [
    "COST_ID"
  ],
  "is_unique": true,
  "non_null_rows": 0,
  "warnings": []
}
------------------------------------------
# data_profiler - get_pk (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE VENDOR  ... IS_CURRENT CREATED_BY    pk
0      1001     SCL*Robi-LP-001855-1*BH*2    SCL  ...          1        NaN  1001
1      1002    SCL*Robi-LP-001855-6*MBH*1    SCL  ...          1        NaN  1002
2      1003    SCL*Robi-LP-001855-7*MBH*1    SCL  ...          1        NaN  1003
3      1004    SCL*Robi-LP-001855-7*MBH*2    SCL  ...          1        NaN  1004
4      1005    SCL*Robi-LP-001855-3*MBH*1    SCL  ...          1        NaN  1005
5      1006    FHL*ROBI-TH-LP-230030*BH*3    FHL  ...          1        NaN  1006
6      1007    FHL*ROBI-TH-LP-230030*BH*2    FHL  ...          1        NaN  1007
7      1008    FHL*ROBI-TH-LP-230030*LM*2    FHL  ...          1        NaN  1008
8      1009    FHL*ROBI-TH-LP-230030*LM*3    FHL  ...          1        NaN  1009
9      1010    FHL*ROBI-TH-LP-230030*BH*1    FHL  ...          1        NaN  1010
10     1011    FHL*ROBI-TH-LP-230030*LM*1    FHL  ...          1        NaN  1011
11     1012     FHL*Robi-LP-001358-5*BH*1    FHL  ...          1        NaN  1012
12     1013     FHL*Robi-LP-001358-5*BH*2    FHL  ...          1        NaN  1013
13     1014     FHL*Robi-LP-001358-5*BH*3    FHL  ...          1        NaN  1014
14     1015     FHL*Robi-LP-001358-5*LM*1    FHL  ...          1        NaN  1015
15     1016     FHL*Robi-LP-001358-5*LM*2    FHL  ...          1        NaN  1016
16     1017     FHL*Robi-LP-001358-5*LM*3    FHL  ...          1        NaN  1017
17     1018     SCL*Robi-LP-001855-4*BH*1    SCL  ...          1        NaN  1018
18     1019     SCL*Robi-LP-001855-4*BH*2    SCL  ...          1        NaN  1019
19     1020     SCL*Robi-LP-001855-4*LM*1    SCL  ...          1        NaN  1020
20     1021     SCL*Robi-LP-001091-3*BH*1    SCL  ...          1        NaN  1021
21     1022     SCL*Robi-LP-001091-3*LM*1    SCL  ...          1        NaN  1022
22     1023     FHL*Robi-LP-001090-3*LM*1    FHL  ...          1        NaN  1023
23     1024     FHL*Robi-LP-001...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000189B5D106D0>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000189B5DBE550>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota_evolve

[
  "UNIT_COST_PER_MBPS_MONTHLY",
  "EFFECTIVE_START_TIME",
  "MAX_CAPACITY",
  "CONTRACT",
  "REMARKS",
  "EFFECTIVE_END_TIME",
  "IS_CURRENT",
  "MIN_CAPACITY",
  "LINK_TYPE",
  "MINSLAB",
  "LOCKIN_MONTHS",
  "BUCKET",
  "CREATED_BY"
]
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: [{'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL'}, {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL'}, {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1006.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*3', 'vendor': 'FHL'}, {'cost_id': 1007.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*2', 'vendor': 'FHL'}, {'cost_id': 1008.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*LM*2', 'vendor': 'FHL'}  ... displaying 10 of 33 total bound parameter sets ...  {'cost_id': 1032.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*1', 'vendor': 'SCL'}, {'cost_id': 1033.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*2', 'vendor': 'SCL'}]]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
Stats: 0/33 succeeded

⚠️ Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=1, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=2, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=3, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=4, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# data_profiler - profile_dataframe (START)
- inputs:
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])

# data_profiler - profile_dataframe (SUCCESS)
- outputs:
  DataFrame(shape=(3, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])
------------------------------------------
# data_profiler - get_pk (START)
- inputs:
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dfinfo: DataFrame(shape=(3, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])

# JSON - pk_detection

{
  "pk_name": "pk",
  "components": [
    "COST_ID"
  ],
  "is_unique": true,
  "non_null_rows": 0,
  "warnings": []
}
------------------------------------------
# data_profiler - get_pk (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR    pk
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL  1001
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL  1002
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL  1003
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL  1004
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL  1005, 'pk', {'components': ['COST_ID'], 'is_unique': True, 'non_null_pk_rows': 0})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota_evolve

CREATE TABLE TEST_QUOTA_EVOLVE (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota_evolve

{
  "table": "test_quota_evolve",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA_EVOLVE (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota_evolve', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000013BBD435A90>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000013BBD6B90D0>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# data_profiler - profile_dataframe (START)
- inputs:
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])

# JSON - high_null_columns

[
  {
    "Column": "REMARKS",
    "Data Type": "object",
    "Is Categorical": "False",
    "All Unique": "False",
    "Is Datetime": false,
    "Count of None": "25",
    "Data Length (Non-Null)": "8",
    "% of None": 75.76,
    "Total Unique Data Points": 5
  },
  {
    "Column": "CREATED_BY",
    "Data Type": "float64",
    "Is Categorical": "False",
    "All Unique": "False",
    "Is Datetime": false,
    "Count of None": "33",
    "Data Length (Non-Null)": "0",
    "% of None": 100.0,
    "Total Unique Data Points": 0
  }
]
------------------------------------------
# data_profiler - profile_dataframe (SUCCESS)
- outputs:
  DataFrame(shape=(16, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])
------------------------------------------
# data_profiler - get_pk (START)
- inputs:
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dfinfo: DataFrame(shape=(16, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])

# JSON - pk_detection

{
  "pk_name": "pk",
  "components": [
    "COST_ID"
  ],
  "is_unique": true,
  "non_null_rows": 0,
  "warnings": []
}
------------------------------------------
# data_profiler - get_pk (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... CREATED_BY    pk
0      1001     SCL*Robi-LP-001855-1*BH*2  ...        NaN  1001
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...        NaN  1002
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...        NaN  1003
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...        NaN  1004
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...        NaN  1005
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...        NaN  1006
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...        NaN  1007
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...        NaN  1008
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...        NaN  1009
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...        NaN  1010
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...        NaN  1011
11     1012     FHL*Robi-LP-001358-5*BH*1  ...        NaN  1012
12     1013     FHL*Robi-LP-001358-5*BH*2  ...        NaN  1013
13     1014     FHL*Robi-LP-001358-5*BH*3  ...        NaN  1014
14     1015     FHL*Robi-LP-001358-5*LM*1  ...        NaN  1015
15     1016     FHL*Robi-LP-001358-5*LM*2  ...        NaN  1016
16     1017     FHL*Robi-LP-001358-5*LM*3  ...        NaN  1017
17     1018     SCL*Robi-LP-001855-4*BH*1  ...        NaN  1018
18     1019     SCL*Robi-LP-001855-4*BH*2  ...        NaN  1019
19     1020     SCL*Robi-LP-001855-4*LM*1  ...        NaN  1020
20     1021     SCL*Robi-LP-001091-3*BH*1  ...        NaN  1021
21     1022     SCL*Robi-LP-001091-3*LM*1  ...        NaN  1022
22     1023     FHL*Robi-LP-001090-3*LM*1  ...        NaN  1023
23     1024     FHL*Robi-LP-001090-3*LM*2  ...        NaN  1024
24     1025     FHL*Robi-LP-001090-3*BH*3  ...        NaN  1025
25     1026     SCL*Robi-LP-001855-1*BH*1  ...        NaN  1026
26     1027     FHL*Robi-LP-001358-3*BH*1  ...        NaN  1027
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...        NaN  1028
28     1029   SCL*Robi-LP-001855-7-1*LM*2  ...        NaN  1029
29     1030   SCL*Robi-LP-001855-7-1*BH*1  ...        NaN  1030
30     1031  FH...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000013BBEAB3C90>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000013BBEB9FE10>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota_evolve

[
  "CONTRACT",
  "UNIT_COST_PER_MBPS_MONTHLY",
  "MIN_CAPACITY",
  "IS_CURRENT",
  "LOCKIN_MONTHS",
  "CREATED_BY",
  "LINK_TYPE",
  "EFFECTIVE_END_TIME",
  "EFFECTIVE_START_TIME",
  "MINSLAB",
  "MAX_CAPACITY",
  "REMARKS",
  "BUCKET"
]
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: [{'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL'}, {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL'}, {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1006.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*3', 'vendor': 'FHL'}, {'cost_id': 1007.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*2', 'vendor': 'FHL'}, {'cost_id': 1008.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*LM*2', 'vendor': 'FHL'}  ... displaying 10 of 33 total bound parameter sets ...  {'cost_id': 1032.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*1', 'vendor': 'SCL'}, {'cost_id': 1033.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*2', 'vendor': 'SCL'}]]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=1, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=2, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=3, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=4, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# data_profiler - profile_dataframe (START)
- inputs:
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])

# JSON - high_null_columns

[
  {
    "Column": "REMARKS",
    "Data Type": "object",
    "Is Categorical": "False",
    "All Unique": "False",
    "Is Datetime": false,
    "Count of None": "25",
    "Data Length (Non-Null)": "8",
    "% of None": 75.76,
    "Total Unique Data Points": 5
  },
  {
    "Column": "CREATED_BY",
    "Data Type": "float64",
    "Is Categorical": "False",
    "All Unique": "False",
    "Is Datetime": false,
    "Count of None": "33",
    "Data Length (Non-Null)": "0",
    "% of None": 100.0,
    "Total Unique Data Points": 0
  }
]
------------------------------------------
# data_profiler - profile_dataframe (SUCCESS)
- outputs:
  DataFrame(shape=(16, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])
------------------------------------------
# data_profiler - get_pk (START)
- inputs:
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dfinfo: DataFrame(shape=(16, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])

# JSON - pk_detection

{
  "pk_name": "pk",
  "components": [
    "COST_ID"
  ],
  "is_unique": true,
  "non_null_rows": 0,
  "warnings": []
}
------------------------------------------
# data_profiler - get_pk (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... CREATED_BY    pk
0      1001     SCL*Robi-LP-001855-1*BH*2  ...        NaN  1001
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...        NaN  1002
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...        NaN  1003
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...        NaN  1004
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...        NaN  1005
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...        NaN  1006
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...        NaN  1007
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...        NaN  1008
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...        NaN  1009
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...        NaN  1010
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...        NaN  1011
11     1012     FHL*Robi-LP-001358-5*BH*1  ...        NaN  1012
12     1013     FHL*Robi-LP-001358-5*BH*2  ...        NaN  1013
13     1014     FHL*Robi-LP-001358-5*BH*3  ...        NaN  1014
14     1015     FHL*Robi-LP-001358-5*LM*1  ...        NaN  1015
15     1016     FHL*Robi-LP-001358-5*LM*2  ...        NaN  1016
16     1017     FHL*Robi-LP-001358-5*LM*3  ...        NaN  1017
17     1018     SCL*Robi-LP-001855-4*BH*1  ...        NaN  1018
18     1019     SCL*Robi-LP-001855-4*BH*2  ...        NaN  1019
19     1020     SCL*Robi-LP-001855-4*LM*1  ...        NaN  1020
20     1021     SCL*Robi-LP-001091-3*BH*1  ...        NaN  1021
21     1022     SCL*Robi-LP-001091-3*LM*1  ...        NaN  1022
22     1023     FHL*Robi-LP-001090-3*LM*1  ...        NaN  1023
23     1024     FHL*Robi-LP-001090-3*LM*2  ...        NaN  1024
24     1025     FHL*Robi-LP-001090-3*BH*3  ...        NaN  1025
25     1026     SCL*Robi-LP-001855-1*BH*1  ...        NaN  1026
26     1027     FHL*Robi-LP-001358-3*BH*1  ...        NaN  1027
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...        NaN  1028
28     1029   SCL*Robi-LP-001855-7-1*LM*2  ...        NaN  1029
29     1030   SCL*Robi-LP-001855-7-1*BH*1  ...        NaN  1030
30     1031  FH...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000013BBEB13510>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000013BBEAB3E90>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000013BBEB13550>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False,...
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_insert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: [{'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 100, 'unit_cost_per_mbps_monthly': 30.0, 'minslab': 70000, 'lockin_months': 1, 'remarks': 'No per mbps rate', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-6', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 1, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 12, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 2, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-3', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1006.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*3', 'vendor': 'FHL', 'contract': 'ROBI-TH-LP-230030', 'link_type': 'BH', 'bucket': 3, 'min_capacity': 1, 'max_capacity': 1000, 'unit_cost_per_mbps_monthly': 207.0, 'minslab': 0, 'lockin_months': 36, 'remarks': 'Regular Price', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1007.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*2', 'vendor': 'FHL', 'contract': 'ROBI-TH-LP-230030', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 2501, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 98.0, 'minslab': 0, 'lockin_months': 36, 'remarks': 'Regular Price', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1008.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*LM*2', 'vendor': 'FHL', 'contract': 'ROBI-TH-LP-230030', 'link_type': 'LM', 'bucket': 2, 'min_capacity': 101, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 88.0, 'minslab': 0, 'lockin_months': 36, 'remarks': 'Regular Price', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}  ... displaying 10 of 33 total bound parameter sets ...  {'cost_id': 1032.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'LM', 'bucket': 1, 'min_capacity': 1, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 86.0, 'minslab': 0, 'lockin_months': 1, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 13, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 2, 'created_by': None}, {'cost_id': 1033.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'LM', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 118.0, 'minslab': 0, 'lockin_months': 1, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 14, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 3, 'created_by': None}]]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 100, 'unit_cost_per_mbps_monthly': 30.0, 'minslab': 70000, 'lockin_months': 1, 'remarks': 'No per mbps rate', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=1, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-6', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 1, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=2, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 12, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=3, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 2, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=4, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-3', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# data_profiler - profile_dataframe (START)
- inputs:
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])

# data_profiler - profile_dataframe (SUCCESS)
- outputs:
  DataFrame(shape=(3, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])
------------------------------------------
# data_profiler - get_pk (START)
- inputs:
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dfinfo: DataFrame(shape=(3, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])

# JSON - pk_detection

{
  "pk_name": "pk",
  "components": [
    "COST_ID"
  ],
  "is_unique": true,
  "non_null_rows": 0,
  "warnings": []
}
------------------------------------------
# data_profiler - get_pk (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR    pk
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL  1001
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL  1002
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL  1003
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL  1004
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL  1005, 'pk', {'components': ['COST_ID'], 'is_unique': True, 'non_null_pk_rows': 0})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota_evolve

CREATE TABLE TEST_QUOTA_EVOLVE (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota_evolve

{
  "table": "test_quota_evolve",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA_EVOLVE (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota_evolve', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001B57ED60850>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001B52E346950>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# data_profiler - profile_dataframe (START)
- inputs:
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])

# JSON - high_null_columns

[
  {
    "Column": "REMARKS",
    "Data Type": "object",
    "Is Categorical": "False",
    "All Unique": "False",
    "Is Datetime": false,
    "Count of None": "25",
    "Data Length (Non-Null)": "8",
    "% of None": 75.76,
    "Total Unique Data Points": 5
  },
  {
    "Column": "CREATED_BY",
    "Data Type": "float64",
    "Is Categorical": "False",
    "All Unique": "False",
    "Is Datetime": false,
    "Count of None": "33",
    "Data Length (Non-Null)": "0",
    "% of None": 100.0,
    "Total Unique Data Points": 0
  }
]
------------------------------------------
# data_profiler - profile_dataframe (SUCCESS)
- outputs:
  DataFrame(shape=(16, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])
------------------------------------------
# data_profiler - get_pk (START)
- inputs:
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dfinfo: DataFrame(shape=(16, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])

# JSON - pk_detection

{
  "pk_name": "pk",
  "components": [
    "COST_ID"
  ],
  "is_unique": true,
  "non_null_rows": 0,
  "warnings": []
}
------------------------------------------
# data_profiler - get_pk (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... CREATED_BY    pk
0      1001     SCL*Robi-LP-001855-1*BH*2  ...        NaN  1001
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...        NaN  1002
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...        NaN  1003
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...        NaN  1004
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...        NaN  1005
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...        NaN  1006
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...        NaN  1007
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...        NaN  1008
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...        NaN  1009
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...        NaN  1010
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...        NaN  1011
11     1012     FHL*Robi-LP-001358-5*BH*1  ...        NaN  1012
12     1013     FHL*Robi-LP-001358-5*BH*2  ...        NaN  1013
13     1014     FHL*Robi-LP-001358-5*BH*3  ...        NaN  1014
14     1015     FHL*Robi-LP-001358-5*LM*1  ...        NaN  1015
15     1016     FHL*Robi-LP-001358-5*LM*2  ...        NaN  1016
16     1017     FHL*Robi-LP-001358-5*LM*3  ...        NaN  1017
17     1018     SCL*Robi-LP-001855-4*BH*1  ...        NaN  1018
18     1019     SCL*Robi-LP-001855-4*BH*2  ...        NaN  1019
19     1020     SCL*Robi-LP-001855-4*LM*1  ...        NaN  1020
20     1021     SCL*Robi-LP-001091-3*BH*1  ...        NaN  1021
21     1022     SCL*Robi-LP-001091-3*LM*1  ...        NaN  1022
22     1023     FHL*Robi-LP-001090-3*LM*1  ...        NaN  1023
23     1024     FHL*Robi-LP-001090-3*LM*2  ...        NaN  1024
24     1025     FHL*Robi-LP-001090-3*BH*3  ...        NaN  1025
25     1026     SCL*Robi-LP-001855-1*BH*1  ...        NaN  1026
26     1027     FHL*Robi-LP-001358-3*BH*1  ...        NaN  1027
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...        NaN  1028
28     1029   SCL*Robi-LP-001855-7-1*LM*2  ...        NaN  1029
29     1030   SCL*Robi-LP-001855-7-1*BH*1  ...        NaN  1030
30     1031  FH...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001B52E333BD0>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001B52E3463D0>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota_evolve

[
  "LOCKIN_MONTHS",
  "IS_CURRENT",
  "CREATED_BY",
  "MINSLAB",
  "REMARKS",
  "EFFECTIVE_START_TIME",
  "MAX_CAPACITY",
  "BUCKET",
  "UNIT_COST_PER_MBPS_MONTHLY",
  "EFFECTIVE_END_TIME",
  "MIN_CAPACITY",
  "CONTRACT",
  "LINK_TYPE"
]
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: [{'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL'}, {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL'}, {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1006.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*3', 'vendor': 'FHL'}, {'cost_id': 1007.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*2', 'vendor': 'FHL'}, {'cost_id': 1008.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*LM*2', 'vendor': 'FHL'}  ... displaying 10 of 33 total bound parameter sets ...  {'cost_id': 1032.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*1', 'vendor': 'SCL'}, {'cost_id': 1033.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*2', 'vendor': 'SCL'}]]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=1, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=2, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=3, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=4, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# data_profiler - profile_dataframe (START)
- inputs:
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])

# JSON - high_null_columns

[
  {
    "Column": "REMARKS",
    "Data Type": "object",
    "Is Categorical": "False",
    "All Unique": "False",
    "Is Datetime": false,
    "Count of None": "25",
    "Data Length (Non-Null)": "8",
    "% of None": 75.76,
    "Total Unique Data Points": 5
  },
  {
    "Column": "CREATED_BY",
    "Data Type": "float64",
    "Is Categorical": "False",
    "All Unique": "False",
    "Is Datetime": false,
    "Count of None": "33",
    "Data Length (Non-Null)": "0",
    "% of None": 100.0,
    "Total Unique Data Points": 0
  }
]
------------------------------------------
# data_profiler - profile_dataframe (SUCCESS)
- outputs:
  DataFrame(shape=(16, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])
------------------------------------------
# data_profiler - get_pk (START)
- inputs:
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dfinfo: DataFrame(shape=(16, 9), columns=['Column', 'Data Type', 'Is Categorical', 'All Unique', 'Is Datetime', 'Count of None', 'Data Length (Non-Null)', '% of None', 'Total Unique Data Points'])

# JSON - pk_detection

{
  "pk_name": "pk",
  "components": [
    "COST_ID"
  ],
  "is_unique": true,
  "non_null_rows": 0,
  "warnings": []
}
------------------------------------------
# data_profiler - get_pk (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... CREATED_BY    pk
0      1001     SCL*Robi-LP-001855-1*BH*2  ...        NaN  1001
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...        NaN  1002
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...        NaN  1003
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...        NaN  1004
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...        NaN  1005
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...        NaN  1006
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...        NaN  1007
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...        NaN  1008
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...        NaN  1009
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...        NaN  1010
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...        NaN  1011
11     1012     FHL*Robi-LP-001358-5*BH*1  ...        NaN  1012
12     1013     FHL*Robi-LP-001358-5*BH*2  ...        NaN  1013
13     1014     FHL*Robi-LP-001358-5*BH*3  ...        NaN  1014
14     1015     FHL*Robi-LP-001358-5*LM*1  ...        NaN  1015
15     1016     FHL*Robi-LP-001358-5*LM*2  ...        NaN  1016
16     1017     FHL*Robi-LP-001358-5*LM*3  ...        NaN  1017
17     1018     SCL*Robi-LP-001855-4*BH*1  ...        NaN  1018
18     1019     SCL*Robi-LP-001855-4*BH*2  ...        NaN  1019
19     1020     SCL*Robi-LP-001855-4*LM*1  ...        NaN  1020
20     1021     SCL*Robi-LP-001091-3*BH*1  ...        NaN  1021
21     1022     SCL*Robi-LP-001091-3*LM*1  ...        NaN  1022
22     1023     FHL*Robi-LP-001090-3*LM*1  ...        NaN  1023
23     1024     FHL*Robi-LP-001090-3*LM*2  ...        NaN  1024
24     1025     FHL*Robi-LP-001090-3*BH*3  ...        NaN  1025
25     1026     SCL*Robi-LP-001855-1*BH*1  ...        NaN  1026
26     1027     FHL*Robi-LP-001358-3*BH*1  ...        NaN  1027
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...        NaN  1028
28     1029   SCL*Robi-LP-001855-7-1*LM*2  ...        NaN  1029
29     1030   SCL*Robi-LP-001855-7-1*BH*1  ...        NaN  1030
30     1031  FH...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001B52E3B6410>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001B52E3B5150>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001B52E3F0410>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False,...
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_insert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: [{'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 100, 'unit_cost_per_mbps_monthly': 30.0, 'minslab': 70000, 'lockin_months': 1, 'remarks': 'No per mbps rate', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-6', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 1, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 12, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 2, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-3', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1006.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*3', 'vendor': 'FHL', 'contract': 'ROBI-TH-LP-230030', 'link_type': 'BH', 'bucket': 3, 'min_capacity': 1, 'max_capacity': 1000, 'unit_cost_per_mbps_monthly': 207.0, 'minslab': 0, 'lockin_months': 36, 'remarks': 'Regular Price', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1007.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*2', 'vendor': 'FHL', 'contract': 'ROBI-TH-LP-230030', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 2501, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 98.0, 'minslab': 0, 'lockin_months': 36, 'remarks': 'Regular Price', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1008.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*LM*2', 'vendor': 'FHL', 'contract': 'ROBI-TH-LP-230030', 'link_type': 'LM', 'bucket': 2, 'min_capacity': 101, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 88.0, 'minslab': 0, 'lockin_months': 36, 'remarks': 'Regular Price', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}  ... displaying 10 of 33 total bound parameter sets ...  {'cost_id': 1032.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'LM', 'bucket': 1, 'min_capacity': 1, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 86.0, 'minslab': 0, 'lockin_months': 1, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 13, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 2, 'created_by': None}, {'cost_id': 1033.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'LM', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 118.0, 'minslab': 0, 'lockin_months': 1, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 14, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 3, 'created_by': None}]]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 100, 'unit_cost_per_mbps_monthly': 30.0, 'minslab': 70000, 'lockin_months': 1, 'remarks': 'No per mbps rate', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=1, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-6', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 1, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=2, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 12, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=3, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 2, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=4, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-3', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota_evolve

CREATE TABLE TEST_QUOTA_EVOLVE (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota_evolve

{
  "table": "test_quota_evolve",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA_EVOLVE (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota_evolve', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000153AFACBE50>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000153AFACBA50>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000153AFACBC10>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000153AFEC9150>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota_evolve

[
  "LINK_TYPE",
  "UNIT_COST_PER_MBPS_MONTHLY",
  "LOCKIN_MONTHS",
  "EFFECTIVE_END_TIME",
  "REMARKS",
  "CREATED_BY",
  "CONTRACT",
  "IS_CURRENT",
  "BUCKET",
  "EFFECTIVE_START_TIME",
  "MIN_CAPACITY",
  "MAX_CAPACITY",
  "MINSLAB"
]
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: [{'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL'}, {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL'}, {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL'}, {'cost_id': 1006.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*3', 'vendor': 'FHL'}, {'cost_id': 1007.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*2', 'vendor': 'FHL'}, {'cost_id': 1008.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*LM*2', 'vendor': 'FHL'}  ... displaying 10 of 33 total bound parameter sets ...  {'cost_id': 1032.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*1', 'vendor': 'SCL'}, {'cost_id': 1033.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*2', 'vendor': 'SCL'}]]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=1, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=2, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=3, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=4, row_keys=['cost_code', 'cost_id', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor) VALUES (:cost_id, :cost_code, :vendor)]
[parameters: {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL'}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000153AFEB8ED0>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000153AFEC1210>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000153AFED3850>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False,...
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_insert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: [{'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 100, 'unit_cost_per_mbps_monthly': 30.0, 'minslab': 70000, 'lockin_months': 1, 'remarks': 'No per mbps rate', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-6', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 1, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 12, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 2, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-3', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1006.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*3', 'vendor': 'FHL', 'contract': 'ROBI-TH-LP-230030', 'link_type': 'BH', 'bucket': 3, 'min_capacity': 1, 'max_capacity': 1000, 'unit_cost_per_mbps_monthly': 207.0, 'minslab': 0, 'lockin_months': 36, 'remarks': 'Regular Price', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1007.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*BH*2', 'vendor': 'FHL', 'contract': 'ROBI-TH-LP-230030', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 2501, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 98.0, 'minslab': 0, 'lockin_months': 36, 'remarks': 'Regular Price', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}, {'cost_id': 1008.0, 'cost_code': 'FHL*ROBI-TH-LP-230030*LM*2', 'vendor': 'FHL', 'contract': 'ROBI-TH-LP-230030', 'link_type': 'LM', 'bucket': 2, 'min_capacity': 101, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 88.0, 'minslab': 0, 'lockin_months': 36, 'remarks': 'Regular Price', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}  ... displaying 10 of 33 total bound parameter sets ...  {'cost_id': 1032.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'LM', 'bucket': 1, 'min_capacity': 1, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 86.0, 'minslab': 0, 'lockin_months': 1, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 13, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 2, 'created_by': None}, {'cost_id': 1033.0, 'cost_code': 'SCL*Robi-LP-001855-1*LM*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'LM', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 10000, 'unit_cost_per_mbps_monthly': 118.0, 'minslab': 0, 'lockin_months': 1, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 14, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 3, 'created_by': None}]]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1001.0, 'cost_code': 'SCL*Robi-LP-001855-1*BH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-1', 'link_type': 'BH', 'bucket': 2, 'min_capacity': 1, 'max_capacity': 100, 'unit_cost_per_mbps_monthly': 30.0, 'minslab': 70000, 'lockin_months': 1, 'remarks': 'No per mbps rate', 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=1, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1002.0, 'cost_code': 'SCL*Robi-LP-001855-6*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-6', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 1, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=2, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1003.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 12, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=3, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1004.0, 'cost_code': 'SCL*Robi-LP-001855-7*MBH*2', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-7', 'link_type': 'MBH', 'bucket': 2, 'min_capacity': 10000, 'max_capacity': 20000, 'unit_cost_per_mbps_monthly': 78.26, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
row_index=4, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=IntegrityError: (oracledb.exceptions.IntegrityError) ORA-00001: unique constraint (AKOMI.TEST_QUOTA_EVOLVE_PK) violated
Help: https://docs.oracle.com/error-help/db/ora-00001/
[SQL: INSERT INTO test_quota_evolve (cost_id, cost_code, vendor, contract, link_type, bucket, min_capacity, max_capacity, unit_cost_per_mbps_monthly, minslab, lockin_months, remarks, effective_start_time, effective_end_time, is_current, created_by) VALUES (:cost_id, :cost_code, :vendor, :contract, :link_type, :bucket, :min_capacity, :max_capacity, :unit_cost_per_mbps_monthly, :minslab, :lockin_months, :remarks, :effective_start_time, :effective_end_time, :is_current, :created_by)]
[parameters: {'cost_id': 1005.0, 'cost_code': 'SCL*Robi-LP-001855-3*MBH*1', 'vendor': 'SCL', 'contract': 'Robi-LP-001855-3', 'link_type': 'MBH', 'bucket': 1, 'min_capacity': 10000, 'max_capacity': 100000, 'unit_cost_per_mbps_monthly': 60.0, 'minslab': 0, 'lockin_months': 24, 'remarks': None, 'effective_start_time': datetime.datetime(2024, 9, 12, 0, 0, tzinfo=datetime.timezone.utc), 'effective_end_time': datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'is_current': 1, 'created_by': None}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota_evolve

CREATE TABLE TEST_QUOTA_EVOLVE (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota_evolve

{
  "table": "test_quota_evolve",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA_EVOLVE (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota_evolve', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001690F87B850>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001690FBFE8D0>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001690FC71190>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001690FC52890>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota_evolve

[
  "MINSLAB",
  "REMARKS",
  "LINK_TYPE",
  "MAX_CAPACITY",
  "CREATED_BY",
  "LOCKIN_MONTHS",
  "MIN_CAPACITY",
  "EFFECTIVE_START_TIME",
  "EFFECTIVE_END_TIME",
  "IS_CURRENT",
  "BUCKET",
  "UNIT_COST_PER_MBPS_MONTHLY",
  "CONTRACT"
]
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_upsert (FAILURE)
- error: ValueError: constrain column 'COST_ID' not found in table 'test_quota_evolve'
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x000001690FBF3110>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001690FC160D0>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x000001690FC87090>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False,...
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_upsert (FAILURE)
- error: ValueError: constrain column 'COST_ID' not found in table 'test_quota_evolve'
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string', 'contract': 'string', 'link_type': 'string', 'bucket': 'integer', 'min_capacity': 'integer', 'max_capacity': 'integer', 'unit_cost_per_mbps_monthly': 'integer', 'minslab': 'integer', 'lockin_months': 'integer', 'remarks': 'string', 'effective_start_time': 'timestamp', 'effective_end_time': 'timestamp', 'is_current': 'integer', 'created_by': 'integer'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# ddl_create - df_ddl (START)
- inputs:
  input_df_or_csv: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  server: oracle
  pk: ['COST_ID']
  fk: None
  unique: None
  autoincrement: None
  varchar_sizes: None
  rename_column: False

# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  return_dtype_meta: True

# DATAFRAME - cast_df_input

shape=(5, 3)

 COST_ID                  COST_CODE VENDOR
    1001  SCL*Robi-LP-001855-1*BH*2    SCL
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 5
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, {'COST_ID': {'input_dtype': 'int64', 'output_dtype': 'int64'}, 'COST_CODE': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}, 'VENDOR': {'input_dtype': 'object', 'output_dtype': 'object', 'object_semantic_type': 'STRING_OBJECT'}})
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_COST_ID

{
  "pandas_dtype": "int64",
  "sql_type": "NUMBER",
  "server": "oracle",
  "semantic_type": null
}
------------------------------------------
# JSON - type_mapping_COST_CODE

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# JSON - type_mapping_VENDOR

{
  "pandas_dtype": "object",
  "sql_type": "VARCHAR2(255)",
  "server": "oracle",
  "semantic_type": "STRING_OBJECT"
}
------------------------------------------
# STRING - ddl_oracle_test_quota_evolve

CREATE TABLE TEST_QUOTA_EVOLVE (
    COST_ID NUMBER NOT NULL,
    COST_CODE VARCHAR2(255) NOT NULL,
    VENDOR VARCHAR2(255) NOT NULL,
    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)
)
------------------------------------------
# JSON - schema_meta_oracle_test_quota_evolve

{
  "table": "test_quota_evolve",
  "server": "oracle",
  "columns": 3,
  "pk": [
    "COST_ID"
  ]
}
------------------------------------------
# ddl_create - df_ddl (SUCCESS)
- outputs:
  (   COST_ID                   COST_CODE VENDOR
0     1001   SCL*Robi-LP-001855-1*BH*2    SCL
1     1002  SCL*Robi-LP-001855-6*MBH*1    SCL
2     1003  SCL*Robi-LP-001855-7*MBH*1    SCL
3     1004  SCL*Robi-LP-001855-7*MBH*2    SCL
4     1005  SCL*Robi-LP-001855-3*MBH*1    SCL, 'CREATE TABLE TEST_QUOTA_EVOLVE (\n    COST_ID NUMBER NOT NULL,\n    COST_CODE VARCHAR2(255) NOT NULL,\n    VENDOR VARCHAR2(255) NOT NULL,\n    CONSTRAINT TEST_QUOTA_EVOLVE_PK PRIMARY KEY (COST_ID)\n)', {'server': 'oracle', 'schema': None, 'table': 'test_quota_evolve', 'columns': [{'name': 'COST_ID', 'pandas_dtype': 'int64', 'sql_dtype': 'NUMBER', 'nullable': False, 'sample_value': '1001'}, {'name': 'COST_CODE', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL*Robi-LP-001855-1*BH*2', 'semantic_type': 'STRING_OBJECT'}, {'name': 'VENDOR', 'pandas_dtype': 'object', 'sql_dtype': 'VARCHAR2(255)', 'nullable': False, 'sample_value': 'SCL', 'semantic_type': 'STRING_OBJECT'}], 'primary_key': ['COST_ID'], 'foreign_keys': [], 'unique_constraints': [], 'autoincrement': None, 'column_mapping': None, 'row_count': 5, 'column_count': 3})
------------------------------------------
# crud_v2 - auto_insert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  chunk_size: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000286259EE690>
  df: DataFrame(shape=(5, 3), columns=['COST_ID', 'COST_CODE', 'VENDOR'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x00000286248F7D90>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(5, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_insert (SUCCESS)
- outputs:
  5
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: False
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x00000286259D6550>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000028625D82A90>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# JSON - dropped_columns_test_quota_evolve

[
  "BUCKET",
  "MINSLAB",
  "MIN_CAPACITY",
  "LINK_TYPE",
  "IS_CURRENT",
  "MAX_CAPACITY",
  "EFFECTIVE_END_TIME",
  "EFFECTIVE_START_TIME",
  "REMARKS",
  "UNIT_COST_PER_MBPS_MONTHLY",
  "CONTRACT",
  "LOCKIN_MONTHS",
  "CREATED_BY"
]
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 3), columns=['cost_id', 'cost_code', 'vendor'])
------------------------------------------
# crud_v2 - auto_upsert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: TypeError: bindparam() got multiple values for argument 'key'
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['cost_code', 'cost_id', 'vendor'], error=TypeError: bindparam() got multiple values for argument 'key'
row_index=1, row_keys=['cost_code', 'cost_id', 'vendor'], error=TypeError: bindparam() got multiple values for argument 'key'
row_index=2, row_keys=['cost_code', 'cost_id', 'vendor'], error=TypeError: bindparam() got multiple values for argument 'key'
row_index=3, row_keys=['cost_code', 'cost_id', 'vendor'], error=TypeError: bindparam() got multiple values for argument 'key'
row_index=4, row_keys=['cost_code', 'cost_id', 'vendor'], error=TypeError: bindparam() got multiple values for argument 'key'
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# casting - cast_df (START)
- inputs:
  obj: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  dtype: {'cost_id': 'integer', 'cost_code': 'string', 'vendor': 'string'}
  return_dtype_meta: True
  kwargs: {'infer_threshold': 1}

# DATAFRAME - cast_df_input

shape=(33, 16)

 COST_ID                  COST_CODE VENDOR         CONTRACT LINK_TYPE  BUCKET  MIN_CAPACITY  MAX_CAPACITY  UNIT_COST_PER_MBPS_MONTHLY  MINSLAB  LOCKIN_MONTHS          REMARKS EFFECTIVE_START_TIME EFFECTIVE_END_TIME  IS_CURRENT  CREATED_BY
    1001  SCL*Robi-LP-001855-1*BH*2    SCL Robi-LP-001855-1        BH       2             1           100                       30.00    70000              1 No per mbps rate            9/12/2024           1/1/1970           1         NaN
    1002 SCL*Robi-LP-001855-6*MBH*1    SCL Robi-LP-001855-6       MBH       1             1        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1003 SCL*Robi-LP-001855-7*MBH*1    SCL Robi-LP-001855-7       MBH       1         10000         20000                       78.26        0             12              NaN            9/12/2024           1/1/1970           1         NaN
    1004 SCL*Robi-LP-001855-7*MBH*2    SCL Robi-LP-001855-7       MBH       2         10000         20000                       78.26        0             24              NaN            9/12/2024           1/1/1970           1         NaN
    1005 SCL*Robi-LP-001855-3*MBH*1    SCL Robi-LP-001855-3       MBH       1         10000        100000                       60.00        0             24              NaN            9/12/2024           1/1/1970           1         NaN
... (28 more rows)
------------------------------------------
# JSON - semantic_type_COST_CODE

{
  "column": "COST_CODE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_VENDOR

{
  "column": "VENDOR",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_CONTRACT

{
  "column": "CONTRACT",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_LINK_TYPE

{
  "column": "LINK_TYPE",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 33
}
------------------------------------------
# JSON - semantic_type_REMARKS

{
  "column": "REMARKS",
  "semantic_type": "STRING_OBJECT",
  "sample_size": 8
}
------------------------------------------
# JSON - dtype_transitions

{
  "COST_ID": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "COST_CODE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "VENDOR": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "CONTRACT": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "LINK_TYPE": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "BUCKET": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MIN_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "MAX_CAPACITY": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "UNIT_COST_PER_MBPS_MONTHLY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  },
  "MINSLAB": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "LOCKIN_MONTHS": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "REMARKS": {
    "input_dtype": "object",
    "output_dtype": "object",
    "object_semantic_type": "STRING_OBJECT"
  },
  "EFFECTIVE_START_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "EFFECTIVE_END_TIME": {
    "input_dtype": "object",
    "output_dtype": "datetime64[ns]"
  },
  "IS_CURRENT": {
    "input_dtype": "int64",
    "output_dtype": "int64"
  },
  "CREATED_BY": {
    "input_dtype": "float64",
    "output_dtype": "float64"
  }
}
------------------------------------------
# casting - cast_df (SUCCESS)
- outputs:
  (    COST_ID                     COST_CODE  ... IS_CURRENT CREATED_BY
0      1001     SCL*Robi-LP-001855-1*BH*2  ...          1        NaN
1      1002    SCL*Robi-LP-001855-6*MBH*1  ...          1        NaN
2      1003    SCL*Robi-LP-001855-7*MBH*1  ...          1        NaN
3      1004    SCL*Robi-LP-001855-7*MBH*2  ...          1        NaN
4      1005    SCL*Robi-LP-001855-3*MBH*1  ...          1        NaN
5      1006    FHL*ROBI-TH-LP-230030*BH*3  ...          1        NaN
6      1007    FHL*ROBI-TH-LP-230030*BH*2  ...          1        NaN
7      1008    FHL*ROBI-TH-LP-230030*LM*2  ...          1        NaN
8      1009    FHL*ROBI-TH-LP-230030*LM*3  ...          1        NaN
9      1010    FHL*ROBI-TH-LP-230030*BH*1  ...          1        NaN
10     1011    FHL*ROBI-TH-LP-230030*LM*1  ...          1        NaN
11     1012     FHL*Robi-LP-001358-5*BH*1  ...          1        NaN
12     1013     FHL*Robi-LP-001358-5*BH*2  ...          1        NaN
13     1014     FHL*Robi-LP-001358-5*BH*3  ...          1        NaN
14     1015     FHL*Robi-LP-001358-5*LM*1  ...          1        NaN
15     1016     FHL*Robi-LP-001358-5*LM*2  ...          1        NaN
16     1017     FHL*Robi-LP-001358-5*LM*3  ...          1        NaN
17     1018     SCL*Robi-LP-001855-4*BH*1  ...          1        NaN
18     1019     SCL*Robi-LP-001855-4*BH*2  ...          1        NaN
19     1020     SCL*Robi-LP-001855-4*LM*1  ...          1        NaN
20     1021     SCL*Robi-LP-001091-3*BH*1  ...          1        NaN
21     1022     SCL*Robi-LP-001091-3*LM*1  ...          1        NaN
22     1023     FHL*Robi-LP-001090-3*LM*1  ...          1        NaN
23     1024     FHL*Robi-LP-001090-3*LM*2  ...          1        NaN
24     1025     FHL*Robi-LP-001090-3*BH*3  ...          1        NaN
25     1026     SCL*Robi-LP-001855-1*BH*1  ...          1        NaN
26     1027     FHL*Robi-LP-001358-3*BH*1  ...          1        NaN
27     1028   SCL*Robi-LP-001855-7-1*LM*1  ...          1        Na...
------------------------------------------
# crud_v2 - auto_upsert (START)
- inputs:
  engine: SQLAlchemyEngine(url=oracle+oracledb://akomi:***@localhost:1521/?service_name=XEPDB1)
  data: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  constrain: ['COST_ID']
  chunk: 10000
  add_missing_cols: True
  failure_threshold: 1
  semantic_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# sql_corrector - SchemaAligner.align (START)
- inputs:
  self: <sql_corrector.SchemaAligner object at 0x0000028625DD8990>
  df: DataFrame(shape=(33, 16), columns=['COST_ID', 'COST_CODE', 'VENDOR', 'CONTRACT', 'LINK_TYPE', 'BUCKET', 'MIN_CAPACITY', 'MAX_CAPACITY', 'UNIT_COST_PER_MBPS_MONTHLY', 'MINSLAB', 'LOCKIN_MONTHS', 'REMARKS', 'EFFECTIVE_START_TIME', 'EFFECTIVE_END_TIME', 'IS_CURRENT', 'CREATED_BY'])
  table: test_quota_evolve
  semantic_type_meta: {'COST_CODE': 'STRING_OBJECT', 'VENDOR': 'STRING_OBJECT', 'CONTRACT': 'STRING_OBJECT', 'LINK_TYPE': 'STRING_OBJECT', 'REMARKS': 'STRING_OBJECT'}

# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000028625DDD790>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[])}, constraints=ConstraintInfo(primary_key={'name': 'test_quota_evolve_pk', 'constrained_columns': ['cost_id']}, foreign_keys=[], unique_constraints=[], check_constraints=[], indexes=[]), df_info=None, mapping=None, validation=None, dialect_checks=DialectChecks(dialect='oracle', issues=[], suggestions=['Oracle: Empty strings are treated as NULL. Ensure ETL normalizes empty strings to NULL consistently.']))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CONTRACT (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LINK_TYPE (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: BUCKET (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MIN_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MAX_CAPACITY (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: UNIT_COST_PER_MBPS_MONTHLY (NUMBER)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: MINSLAB (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: LOCKIN_MONTHS (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: REMARKS (VARCHAR2(255))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_START_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: EFFECTIVE_END_TIME (TIMESTAMP)
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: IS_CURRENT (NUMBER(19))
------------------------------------------
# STRING - schema_evolution_test_quota_evolve

Added column: CREATED_BY (NUMBER)
------------------------------------------
# schema_analyzer - SchemaAnalyzer.analyze_table (START)
- inputs:
  self: <schema_analyzer.SchemaAnalyzer object at 0x0000028625DCFD10>
  schema: None
  table_name: test_quota_evolve
  df: None
  run_fk_checks: False

# schema_analyzer - SchemaAnalyzer.analyze_table (SUCCESS)
- outputs:
  TableAnalysisReport(engine_info=EngineInfo(dialect='oracle', driver='oracledb', url='oracle+oracledb://***:***@localhost:1521/?service_name=XEPDB1', connect_ok=False, connect_error="DatabaseError('(oracledb.exceptions.DatabaseError) ORA-00923: FROM keyword not found where expected\\nHelp: https://docs.oracle.com/error-help/db/ora-00923/')"), table_exists=True, schema=None, table_name='test_quota_evolve', table_comment=None, columns={'cost_id': ColumnInfo(name='cost_id', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False, is_boolean=False, length=None, precision=None, scale=None, issues=[], suggestions=[]), 'cost_code': ColumnInfo(name='cost_code', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'vendor': ColumnInfo(name='vendor', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=False, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'contract': ColumnInfo(name='contract', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'link_type': ColumnInfo(name='link_type', type_str='VARCHAR', sqlalchemy_type='VARCHAR(255)', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=False, is_datetime=False, is_boolean=False, length=255, precision=None, scale=None, issues=[], suggestions=[]), 'bucket': ColumnInfo(name='bucket', type_str='NUMBER', sqlalchemy_type='NUMBER', nullable=True, default=None, autoincrement=None, comment=None, is_numeric=True, is_datetime=False,...
------------------------------------------
# JSON - semantic_routing_test_quota_evolve

{
  "COST_CODE": "STRING_OBJECT",
  "VENDOR": "STRING_OBJECT",
  "CONTRACT": "STRING_OBJECT",
  "LINK_TYPE": "STRING_OBJECT",
  "REMARKS": "STRING_OBJECT"
}
------------------------------------------
# sql_corrector - SchemaAligner.align (SUCCESS)
- outputs:
  DataFrame(shape=(33, 16), columns=['cost_id', 'cost_code', 'vendor', 'contract', 'link_type', 'bucket', 'min_capacity', 'max_capacity', 'unit_cost_per_mbps_monthly', 'minslab', 'lockin_months', 'remarks', 'effective_start_time', 'effective_end_time', 'is_current', 'created_by'])
------------------------------------------
# crud_v2 - auto_upsert (FAILURE)
- error: RuntimeError: Bulk operation failed, lazy fallback partially succeeded.
Bulk error: TypeError: bindparam() got multiple values for argument 'key'
Stats: 0/33 succeeded

[!] Processing aborted after 5 failures. 28 rows not attempted.Failing rows (first subset):
row_index=0, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=TypeError: bindparam() got multiple values for argument 'key'
row_index=1, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=TypeError: bindparam() got multiple values for argument 'key'
row_index=2, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=TypeError: bindparam() got multiple values for argument 'key'
row_index=3, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=TypeError: bindparam() got multiple values for argument 'key'
row_index=4, row_keys=['bucket', 'contract', 'cost_code', 'cost_id', 'created_by', 'effective_end_time', 'effective_start_time', 'is_current', 'link_type', 'lockin_months', 'max_capacity', 'min_capacity', 'minslab', 'remarks', 'unit_cost_per_mbps_monthly', 'vendor'], error=TypeError: bindparam() got multiple values for argument 'key'
------------------------------------------
