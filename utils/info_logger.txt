Operational logic: logger loads a YAML-based config or environment variable to decide whether logging is enabled, uses 10-minute time buckets to rotate log files, and exposes decorators/ helpers that capture call inputs/outputs, string/json/dataframe snapshots, and conditional logging wrappers while keeping the main flow unaffected when disabled.
Real-world problem addressed: it instruments ETL helpers with minimal boilerplate so function inputs/outputs/errors can be captured into time-bucketed log files (configurable via config.yml or ETL_LOGGING) without changing business logic.
Control flow: configuration loads at import, creating the log directory and bucket intervals; log_call checks ENABLE_LOGGING, writes start/input snapshots with _safe_str, runs the wrapped function, and appends success or failure sections while swallowing file I/O errors; log_string/log_json/log_dataframe append labeled snapshots to the bucketed file when enabled, and conditional_log_call returns the original function when logging is off to avoid overhead.
Failure modes: when logging is disabled no records are written; file I/O errors are swallowed, hiding permission/disk issues; log_json falls back to a placeholder on serialization failures; log_string/log_dataframe raise TypeError on wrong argument types; no rotation/limits on bucketed files, so aggressive bucket_minutes or unexpected enabling can grow disk usage.
