Operational logic: where_build parses and normalizes WHERE clause fragments, aligns column names to DataFrame schemas, parameterizes values per supported dialects, and emits SELECT/UPDATE/INSERT statements with escaped identifiers.
Real-world problem addressed: it builds parameterized WHERE/UPDATE/SELECT/INSERT SQL from pandas-aligned rows while handling case mismatches, placeholders, and LIKE escaping so callers avoid string-concatenated predicates.
Control flow: conditions are normalized via _flatten/_handle_single/parse_sql_condition, bound parameters are produced in _build_condition with dialect-aware escaping, sql_where composes clauses (optionally via numeric expression references), and statement builders (_select_stmt/_update_stmt/_insert_stmt) align columns to DataFrame rows, replace placeholders with row values, and quote identifiers; build_* wrappers enforce single-row inputs via _ensure_df and generate default expressions when not provided.
Failure modes: invalid condition formats or unsupported operators/dialects raise ValueError; _ensure_df rejects unsupported data types and build_* raise if row count != 1; missing WHERE columns without allow_missing_where_cols triggers ValueError, while placeholders for missing row columns also raise; malformed BETWEEN/IN payloads raise ValueError; debug logging suppresses file errors.
