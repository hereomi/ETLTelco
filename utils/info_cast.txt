Operational logic: cast normalizes pandas-friendly inputs by parsing datetimes via regex/dateutil fallbacks, detecting outliers, and running a casting engine that includes transform_dtypes, optional ML-like classification, and explicit dtype overrides before returning a cleaned DataFrame (with optional metadata on dtype changes).
Real-world problem addressed: it centralizes heuristic dtype inference (datetime hints, currency-aware numerics, boolean mapping), outlier masking, and multiple casting strategies so mixed-type DataFrame inputs can be coerced without duplicating detection heuristics.
Control flow: parse_datetime uses pattern/dateutil parsing over scalars, sequences, or Series; detect_outliers builds a mask by IQR/zscore and replace_outliers_with_zero_safe zeros flagged numeric entries (and NaNs if configured); transform_dtypes applies explicit overrides then scans object columns for datetime/numeric/boolean signatures with currency handling; cast_df selects transform_dtypes, ML-like auto_convert_dtypes_ml, or the original inference path, optionally cleans outliers first, and can return dtype metadata; auto_convert_dtypes_ml uses an inline rule-based classifier to predict column types and convert, falling back per-column on errors.
Failure modes: parse_datetime returns None when patterns and dateutil parsing fail; detect_outliers/replace_outliers_with_zero_safe raise ValueError on non-DataFrame inputs or unsupported methods; _to_dataframe raises ValueError on unsupported inputs; explicit casts in transform_dtypes log debug and leave columns unchanged when they fail, while inferred conversions may coerce to NaN without warning beyond _warn_on_coerce >10% null increase; cast_df warns only for empty frames; ML conversion can introduce NaNs and logs debug on failure but continues.
