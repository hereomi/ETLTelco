Operational logic: crud_v3 builds dialect-specific SQL strings (Oracle MERGE, Postgres INSERT ON CONFLICT, SQLite upsert, MySQL duplicate-key, MSSQL MERGE) by normalizing input data and returning SQLQuery containers that hold statement text plus bound parameters, while also exposing lazy_select_sql and lazy_update_sql helpers that assemble WHERE and SET clauses with safe operator validation.
Real-world problem addressed: it generates ready-to-execute SQL for inserts, upserts, selects, and updates across multiple dialects without requiring SQLAlchemy engines or schema alignment, allowing callers to log or execute the raw statements externally.
Control flow: inputs are normalized via _normalize_data (coercing pandas/numpy nulls) unless already_normalized, then lazy_upsert_sql and lazy_insert_sql iterate rows and pick the dialect-specific builder; select_sql/update_sql enforce ALLOWED_OPERATORS, choose placeholder prefixes per dialect, and assemble SQLQuery objects; lazy_update_sql normalizes, uses only the first row, optionally filters columns by constrain, and delegates to update_sql, while empty or non-list inputs return [] for insert/upsert and raise ValueError for update.
Failure modes: unsupported dialects or operators raise ValueError; _normalize_data rejects unsupported input types; lazy_upsert_sql/lazy_insert_sql silently return [] on empty data; lazy_update_sql raises when no data or when constrain filtering removes all columns; dialect-specific placeholder formats differ (e.g., %(name)s, :name, @name) so caller binding must match; all SQL is raw string composition with no quoting/sanitization beyond placeholder use.
